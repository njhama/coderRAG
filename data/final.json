[
    {
        "question_number": 1249,
        "question_description": "Given a string s of '(' , ')' and lowercase English characters, remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.",
        "examples": [
            {
                "input": {
                    "s": "lee(t(c)o)de)"
                },
                "output": "lee(t(c)o)de"
            },
            {
                "input": {
                    "s": "a)b(c)d"
                },
                "output": "ab(c)d"
            }
        ],
        "constraints": "s consists of lowercase English letters and parentheses '('. ')'.",
        "solution_code": "class Solution(object):\n    def minRemoveToMakeValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        s = list(s)  # Convert to list for mutability\n        openVar = 0  # Track unmatched '('\n\n        # First pass: Remove invalid ')'\n        for i in range(len(s)):\n            if s[i] == \"(\":\n                openVar += 1\n            elif s[i] == \")\":\n                if openVar == 0:\n                    s[i] = \"\"  # Remove unmatched ')'\n                else:\n                    openVar -= 1\n\n        # Second pass: Remove invalid '(' (traverse backward)\n        closeVar = 0\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == \")\":\n                closeVar += 1\n            elif s[i] == \"(\":\n                if closeVar == 0:\n                    s[i] = \"\"  # Remove unmatched '('\n                else:\n                    closeVar -= 1\n\n        return \"\".join(s)"
    },
    {
        "question_number": 408,
        "question_description": "Given a non-empty string word and an abbreviation abbr, return whether the string matches with the given abbreviation.",
        "examples": [
            {
                "input": {
                    "word": "internationalization",
                    "abbr": "i12iz4n"
                },
                "output": true
            },
            {
                "input": {
                    "word": "apple",
                    "abbr": "a2e"
                },
                "output": false
            }
        ],
        "constraints": "1 <= word.length <= 20. abbr consists of lowercase English letters and digits.",
        "solution_code": "class Solution(object):\n    def validWordAbbreviation(self, word, abbr):\n        \"\"\"\n        :type word: str\n        :type abbr: str\n        :rtype: bool\n        \"\"\"\n        word_index = 0\n        abbr_index = 0\n        \n        while word_index < len(word) and abbr_index < len(abbr):\n            if abbr[abbr_index].isdigit():\n                # Handle leading zeros\n                if abbr[abbr_index] == '0':\n                    return False\n                \n                # Parse the number from abbr\n                num = 0\n                while abbr_index < len(abbr) and abbr[abbr_index].isdigit():\n                    num = num * 10 + int(abbr[abbr_index])\n                    abbr_index += 1\n                \n                # Move word_index forward by the number parsed\n                word_index += num\n            else:\n                # Check if characters match\n                if word[word_index] != abbr[abbr_index]:\n                    return False\n                word_index += 1\n                abbr_index += 1\n        \n        # Ensure both strings are fully processed\n        return word_index == len(word) and abbr_index == len(abbr)\n"
    },
    {
        "question_number": 680,
        "question_description": "Given a string s, return true if the s can be palindrome after deleting at most one character from it.",
        "examples": [
            {
                "input": {
                    "s": "abca"
                },
                "output": true
            },
            {
                "input": {
                    "s": "racecar"
                },
                "output": true
            }
        ],
        "constraints": "s consists of lowercase English letters.",
        "solution_code": "class Solution(object):\n    def validPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        def is_palindrome_range(l, r):\n            \"\"\"Check if s[l:r+1] is a palindrome.\"\"\"\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            if s[l] != s[r]:\n                # Check both possibilities: skip l or skip r\n                #return s[l+1:r+1] == s[l+1:r+1][::-1] or s[l:r] == s[l:r][::-1]\n                return is_palindrome_range(l + 1, r) or is_palindrome_range(l, r - 1)\n            l += 1\n            r -= 1\n\n        return True\n"
    },
    {
        "question_number": 528,
        "question_description": "Given an array w of positive integers, where w[i] describes the weight of index i, write a function that randomly picks an index in proportion to its weight.",
        "examples": [
            {
                "input": {
                    "w": [
                        1,
                        3
                    ]
                },
                "output": "Randomly returns index 0 with probability 1/4 and index 1 with probability 3/4."
            }
        ],
        "constraints": "1 <= w.length <= 10000, 1 <= w[i] <= 10^5.",
        "solution_code": "import random\n\nclass Solution:\n    def __init__(self, weights):\n        \"\"\"\n        :type weights: List[int]\n        \"\"\"\n        # Calculate cumulative sums for weighted intervals\n        self.cumulative_sum = []\n        current_sum = 0\n        for weight in weights:\n            current_sum += weight\n            self.cumulative_sum.append(current_sum)\n        self.total_sum = current_sum  # Store the total sum of weights\n\n    def pickIndex(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        # Generate a random target within the range [1, total_sum]\n        target = random.randint(1, self.total_sum)\n        \n        # Binary search to find the smallest index with cumulative_sum >= target\n        low, high = 0, len(self.cumulative_sum) - 1\n        while low < high:\n            mid = (low + high) // 2\n            if target > self.cumulative_sum[mid]:\n                low = mid + 1\n            else:\n                high = mid\n        return low\n"
    },
    {
        "question_number": 1650,
        "question_description": "Given two nodes of a binary tree, find their lowest common ancestor.",
        "examples": null,
        "constraints": "Both nodes exist in the tree.",
        "solution_code": "\nclass Solution(object):\n    def lowestCommonAncestor(self, p, q):\n        \"\"\"\n        Finds the lowest common ancestor (LCA) of two nodes p and q in a binary tree \n        where each node has a parent pointer.\n        \n        :type p: Node\n        :type q: Node\n        :rtype: Node\n        \"\"\"\n        \"\"\"\n        bit slower but \n        a, b = p, q\n        while a != b:\n            # Move `a` up one level, or switch to `q`'s path if `a` reaches the root\n            a = a.parent if a else q\n            # Move `b` up one level, or switch to `p`'s path if `b` reaches the root\n            b = b.parent if b else p\n        return a\n\n        \"\"\"\n        # Set to keep track of visited nodes in the paths of p and q\n        seen = set()\n\n        # Traverse upwards from both nodes until they meet\n        while p or q:\n            # If the pointers meet at a common ancestor, return it\n            if p == q:\n                return p\n            \n            # If `p` has been seen before, it's the LCA\n            if p in seen:\n                return p\n            if q in seen:\n                return q\n            \n            # Mark `p` and `q` as visited and move them up to their parents\n            if p:\n                seen.add(p)\n                p = p.parent\n            if q:\n                seen.add(q)\n                q = q.parent\n\n        return None\n"
    },
    {
        "question_number": 314,
        "question_description": "Given a binary tree, return the vertical order traversal of its nodes' values.",
        "examples": null,
        "constraints": "None",
        "solution_code": "from collections import deque, defaultdict\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution(object):\n    def verticalOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n\n        # Initialize queue for BFS and dictionary for storing nodes by column\n        queue = deque([(root, 0)])  # Each entry is (node, column index)\n        column_table = defaultdict(list)\n        \n        # Perform BFS\n        while queue:\n            node, col = queue.popleft()\n            column_table[col].append(node.val)\n\n            # Add left and right children to the queue with updated column indices\n            if node.left:\n                queue.append((node.left, col - 1))\n            if node.right:\n                queue.append((node.right, col + 1))\n\n        # Sort the columns and collect results\n        result = [column_table[x] for x in sorted(column_table.keys())]\n        return result\n"
    },
    {
        "question_number": 227,
        "question_description": "Implement a basic calculator to evaluate a simple expression string.",
        "examples": null,
        "constraints": "The expression is valid and contains only non-negative integers, '+', '-', '*', '/', and spaces.",
        "solution_code": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result = 0  # Final result\n        last = 0  # Last evaluated term\n        curr = 0  # Current number being processed\n        prev_op = '+'  # Previous operation\n\n        for i, c in enumerate(s):\n            if c.isdigit():\n                curr = curr * 10 + int(c)\n\n            # Process the current operation if it's an operator or the last character\n            if c in \"+-*/\" or i == len(s) - 1:\n                if prev_op == '+':\n                    result += last  # Add the previous term to the result\n                    last = curr     # Set current term as the last term\n                elif prev_op == '-':\n                    result += last  # Add the previous term to the result\n                    last = -curr    # Set negative current term as the last term\n                elif prev_op == '*':\n                    last *= curr    # Multiply last term by current term\n                elif prev_op == '/':\n                    # Division with truncation towards zero\n                    last = int(last / curr) if last >= 0 else -int(abs(last) / curr)\n\n                # Reset `curr` and update `prev_op` to the current operator\n                curr = 0\n                prev_op = c\n\n        result += last  # Add the last term to the result\n        return result\n"
    },
    {
        "question_number": 339,
        "question_description": "Given a nested list of integers, return the sum of all integers in the list weighted by their depth.",
        "examples": null,
        "constraints": "The depth is defined by the number of nested levels.",
        "solution_code": "class Solution(object):\n    def depthSum(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(nestedList, depth):\n            total = 0\n            for nest in nestedList:\n                if nest.isInteger():\n                    # If it's an integer, multiply by the current depth\n                    total += nest.getInteger() * depth\n                else:\n                    # If it's a list, recursively calculate its weighted sum at depth + 1\n                    total += dfs(nest.getList(), depth + 1)\n            return total\n\n        # Start the DFS with an initial depth of 1\n        return dfs(nestedList, 1)\n"
    },
    {
        "question_number": 1570,
        "question_description": "Given two sparse vectors, compute their dot product.",
        "examples": null,
        "constraints": "The vectors contain large numbers of zeroes.",
        "solution_code": "class SparseVector:\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        # Store only the non-zero elements and their indices\n        self.non_zero = {i: val for i, val in enumerate(nums) if val != 0}\n\n    def dotProduct(self, vec):\n        \"\"\"\n        :type vec: 'SparseVector'\n        :rtype: int\n        \"\"\"\n        res = 0\n\n        # Iterate through the non-zero elements of the current vector\n        for i, val in self.non_zero.items():\n            # Multiply only if the index exists in the other vector\n            if i in vec.non_zero:\n                res += val * vec.non_zero[i]\n\n        return res\n"
    },
    {
        "question_number": 215,
        "question_description": "Find the kth largest element in an unsorted array.",
        "examples": null,
        "constraints": "You must solve it in O(n) average time complexity.",
        "solution_code": "import heapq\n\nclass Solution(object):\n    def findKthLargest(self, nums, k):\n        # Step 1: Build a min-heap with the first k elements\n        min_heap = nums[:k]\n        heapq.heapify(min_heap)  # O(k)\n\n        # Step 2: Process the remaining elements\n        for num in nums[k:]:\n            # If the current number is larger than the smallest in the heap, replace it\n            if num > min_heap[0]:\n                heapq.heappushpop(min_heap, num)  # Push and pop in O(log k)\n\n        # Step 3: The root of the heap is the kth largest element\n        return min_heap[0]\n"
    },
    {
        "question_number": 162,
        "question_description": "Given an array of integers, find a peak element.",
        "examples": null,
        "constraints": "You may imagine that nums[-1] = nums[n] = -\u00e2\u02c6\u017e.",
        "solution_code": "class Solution(object):\n    def findPeakElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        # Perform binary search\n        while left < right:\n            mid = (left + right) // 2\n            # Check if the mid element is greater than the next element\n            if nums[mid] > nums[mid + 1]:\n                # A peak must exist on the left (including mid)\n                right = mid\n            else:\n                # A peak must exist on the right (excluding mid)\n                left = mid + 1\n        \n        # Return the peak index\n        return left\n"
    },
    {
        "question_number": 236,
        "question_description": "Find the lowest common ancestor (LCA) of two given nodes in the tree.",
        "examples": null,
        "constraints": "Both nodes exist in the binary tree.",
        "solution_code": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        # Base Case\n        if not root or root == p or root == q:\n            return root\n\n        # Recursively find LCA in left and right subtrees\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n\n        # If both left and right are non-None, current node is the LCA\n        if left and right:\n            return root\n\n        # Otherwise, return the non-None result (either left or right)\n        return left if left else right"
    },
    {
        "question_number": 560,
        "question_description": "Find the number of continuous subarrays whose sum equals to k.",
        "examples": null,
        "constraints": "Assume that the length of nums is at most 20,000.",
        "solution_code": "from collections import defaultdict\n\nclass Solution(object):\n    def subarraySum(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        seen = defaultdict(int)  # To store cumulative sums\n        seen[0] = 1  # A sum of 0 before starting counts as 1 occurrence\n        curr = 0     # Cumulative sum\n        count = 0    # Number of subarrays with sum = k\n\n        for n in nums:\n            curr += n  # Update the cumulative sum\n\n            # Check if there exists a subarray ending at the current index\n            if curr - k in seen:\n                count += seen[curr - k]\n            \n            # Update the frequency of the current cumulative sum\n            seen[curr] += 1\n\n        return count\n"
    },
    {
        "question_number": 71,
        "question_description": "Given an absolute path, simplify it to its canonical path.",
        "examples": null,
        "constraints": "The path must begin with a single '/' and simplify to a canonical path.",
        "solution_code": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        # Use a stack to process directory components\n        stack = []\n        \n        # Split the path into components\n        for part in path.split('/'):\n            if part == \"..\":  # Move up one directory\n                if stack:\n                    stack.pop()\n            elif part == \".\" or not part:  # Ignore current directory or empty components\n                continue\n            else:\n                stack.append(part)  # Valid directory name\n        \n        # Join the stack to form the simplified path\n        return \"/\" + \"/\".join(stack)\n"
    },
    {
        "question_number": 50,
        "question_description": "Implement pow(x, n), which calculates x raised to the power n.",
        "examples": null,
        "constraints": "Do not use built-in functions.",
        "solution_code": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        # 2^10 = 4^5\n        # Handle negative powers\n        if n < 0:\n            x = 1 / x  # Take reciprocal of x\n            n = -n     # Make n positive\n\n        # Initialize the result and the current multiplier\n        res = 1\n        curr = x\n\n        # Exponentiation by squaring\n        while n > 0:\n            # If n is odd, multiply the current result by curr\n            if n % 2 == 1:\n                res *= curr\n                # No need to explicitly decrement n here; division handles it\n\n            # Square the current multiplier for the next iteration\n            curr *= curr\n            # Halve n (integer division)\n            n //= 2\n\n        return res\n"
    },
    {
        "question_number": 283,
        "question_description": "Move all 0's to the end of the array while maintaining the relative order of the non-zero elements.",
        "examples": null,
        "constraints": "Minimize the total number of operations.",
        "solution_code": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Pointer to keep track of the next position for a non-zero element\n        x = 0\n\n        # Iterate through the array\n        for i, n in enumerate(nums):\n            # When a non-zero element is found, swap it with the position at x\n            if n != 0:\n                nums[i], nums[x] = nums[x], nums[i]\n                x += 1\n"
    },
    {
        "question_number": 88,
        "question_description": "Merge two sorted arrays, nums1 and nums2, into one sorted array.",
        "examples": null,
        "constraints": "The merged result must be stored in nums1.",
        "solution_code": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        # Make a copy of the first m elements of nums1\n        nums1_copy = nums1[:m]\n        \n        # Initialize pointers for nums1_copy and nums2\n        p1, p2 = 0, 0\n\n        # Iterate through nums1 and merge the elements in sorted order\n        for p in range(m + n):\n            # Check if nums2 is exhausted or nums1_copy has a smaller or equal value\n            if p2 >= n or (p1 < m and nums1_copy[p1] <= nums2[p2]):\n                nums1[p] = nums1_copy[p1]\n                p1 += 1\n            else:  # Otherwise, take the next value from nums2\n                nums1[p] = nums2[p2]\n                p2 += 1\n"
    },
    {
        "question_number": 1091,
        "question_description": "Find the shortest path in a binary matrix from top-left to bottom-right.",
        "examples": null,
        "constraints": "The grid contains only 0s and 1s.",
        "solution_code": "from collections import deque\n\nclass Solution(object):\n    def shortestPathBinaryMatrix(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        rows = len(grid)\n        cols = len(grid[0])\n        \n        # If the start or end cell is blocked, return -1 immediately\n        if grid[0][0] == 1 or grid[rows - 1][cols - 1] == 1:\n            return -1\n        \n        # Define all possible 8 directions for movement\n        directions = [\n            (-1, -1), (-1, 0), (-1, 1),\n            (1, -1), (1, 0), (1, 1),\n            (0, 1), (0, -1)\n        ]\n        \n        # Initialize the queue for BFS and mark the start cell as visited\n        queue = deque([(0, 0)])\n        grid[0][0] = 1  # Mark the start cell as visited by setting it to 1\n        distance = 1  # Start with a distance of 1 (since we're counting steps)\n        \n        while queue:\n            # Process all nodes at the current level\n            for _ in range(len(queue)):\n                curr_row, curr_col = queue.popleft()\n                \n                # If we've reached the bottom-right cell, return the distance\n                if curr_row == rows - 1 and curr_col == cols - 1:\n                    return distance\n\n                # Explore all 8 possible directions\n                for dr, dc in directions:\n                    new_row, new_col = curr_row + dr, curr_col + dc\n                    \n                    # Check if the new cell is within bounds and not yet visited\n                    if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0:\n                        queue.append((new_row, new_col))  # Add the new cell to the queue\n                        grid[new_row][new_col] = 1  # Mark it as visited\n            \n            # Increment distance after processing all nodes at the current level\n            distance += 1\n        \n        # If we exhaust the queue without reaching the target, there's no path\n        return -1\n"
    },
    {
        "question_number": 138,
        "question_description": "Create a deep copy of a linked list where each node has an additional random pointer.",
        "examples": null,
        "constraints": "Each node's random pointer can point to any node in the list or null.",
        "solution_code": "class Solution(object):\n    def copyRandomList(self, head):\n        \"\"\"\n        :type head: Node\n        :rtype: Node\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        # create another node next to each node\n        node_map = {}\n        current = head\n        while current:\n            node_map[current] = Node(current.val)\n            current = current.next\n        \n        # Step 2: Assign next and random pointers for each copied node\n        current = head\n        while current:\n            if current.next:\n                # set next of copy to the next copy\n                node_map[current].next = node_map[current.next]\n            if current.random:\n                # set the copy random to the next copys random\n                node_map[current].random = node_map[current.random]\n            current = current.next\n        \n        # Step 3: Return the copied head node\n        return node_map[head]\n"
    },
    {
        "question_number": 543,
        "question_description": "Given a binary tree, find the diameter of the tree.",
        "examples": null,
        "constraints": "The number of nodes in the tree is in the range [1, 10^4].",
        "solution_code": "class Solution(object):\n    def diameterOfBinaryTree(self, root):\n        \"\"\"\n        Calculate the diameter of a binary tree, defined as the longest path\n        between any two nodes in the tree.\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.dia = 0  # To store the maximum diameter found\n\n        def height(node):\n            if not node:\n                return 0 \n\n            left = height(node.left)\n            right = height(node.right)\n            self.dia = max(self.dia, left + right)\n            return 1 + max(left, right)\n\n        height(root) \n        return self.dia"
    },
    {
        "question_number": 1762,
        "question_description": "Return a list of buildings that have an ocean view.",
        "examples": null,
        "constraints": "The buildings' heights are given in an integer array.",
        "solution_code": "class Solution(object):\n    def findBuildings(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        highest = 0  # Keeps track of the highest building seen from the right\n\n        for i in range(len(heights) - 1, -1, -1):\n            if heights[i] > highest:\n                res.append(i)  \n                highest = heights[i]\n\n        return res[::-1]  "
    },
    {
        "question_number": 56,
        "question_description": "Given a collection of intervals, merge all overlapping intervals.",
        "examples": null,
        "constraints": "Intervals are represented as pairs [start, end].",
        "solution_code": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not intervals:\n            return []\n\n        sorted_intervals = sorted(intervals, key=lambda x: x[0])\n        # or intervals.sort(key=lambda x: x[0])\n\n        res = []\n        curr = sorted_intervals[0]\n\n        for i in range(1, len(sorted_intervals)):\n            # Check if the current interval can be merged\n            if curr[1] >= sorted_intervals[i][0]:\n                curr[1] = max(curr[1], sorted_intervals[i][1])\n            else:\n                res.append(curr)\n                curr = sorted_intervals[i]\n\n        # Append the last interval\n        res.append(curr)\n        return res"
    },
    {
        "question_number": 125,
        "question_description": "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.",
        "examples": null,
        "constraints": "An empty string is considered a valid palindrome.",
        "solution_code": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            # Move left pointer to the next alphanumeric character\n            while l < r and not s[l].isalnum():\n                l += 1\n            # Move right pointer to the previous alphanumeric character\n            while l < r and not s[r].isalnum():\n                r -= 1\n            \n            # Compare characters, ignoring case\n            if s[l].lower() != s[r].lower():\n                return False\n            \n            l += 1\n            r -= 1\n\n        return True\n"
    },
    {
        "question_number": 921,
        "question_description": "Given a parentheses string, return the minimum number of additions needed to make the string valid.",
        "examples": null,
        "constraints": "The input string consists only of '(' and ')'.",
        "solution_code": "class Solution(object):\n    def minAddToMakeValid(self, s):\n        \"\"\"\n        Calculate the minimum number of parentheses additions required to make a string valid.\n        \n        :type s: str\n        :rtype: int\n        \"\"\"\n        open_count = 0  # Tracks unmatched '('\n        close_count = 0  # Tracks unmatched ')'\n\n        for char in s:\n            if char == \"(\":\n                open_count += 1\n            else:\n                if open_count > 0:\n                    open_count -= 1\n                else:\n                    close_count += 1\n\n        return open_count + close_count\n"
    },
    {
        "question_number": 31,
        "question_description": "Given an array of integers, rearrange them to the next lexicographically greater permutation.",
        "examples": null,
        "constraints": "If no greater permutation is possible, rearrange to the lowest possible order.",
        "solution_code": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n\n        # find hte pivot element\n        \n        i = len(nums) - 2\n        # find nums[i] < nums[i + 1]\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        \n        # find the sucessor # find a j > pivot\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        # revse the right part of i\n        left= i + 1\n        right = len(nums) - 1\n\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n        "
    },
    {
        "question_number": 146,
        "question_description": "Design and implement a data structure for a Least Recently Used (LRU) Cache.",
        "examples": null,
        "constraints": "Implement with O(1) time complexity for put and get operations.",
        "solution_code": "class Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = {}  # Map key to node\n        self.capacity = capacity\n        self.head = Node(0, 0)  # Dummy head\n        self.tail = Node(0, 0)  # Dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node):\n        prev = node.prev\n        nxt = node.next\n        prev.next = nxt\n        nxt.prev = prev\n\n    def _add(self, node):\n        prev = self.tail.prev\n        prev.next = node\n        node.prev = prev\n        node.next = self.tail\n        self.tail.prev = node\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._remove(node)\n        self._add(node)  # Move to the end (most recently used)\n        return node.value\n\n    def put(self, key, value):\n        if key in self.cache:\n            self._remove(self.cache[key])\n        elif len(self.cache) == self.capacity:\n            # Remove least recently used node\n            lru = self.head.next\n            self._remove(lru)\n            del self.cache[lru.key]\n        # Add the new node\n        new_node = Node(key, value)\n        self._add(new_node)\n        self.cache[key] = new_node\n"
    },
    {
        "question_number": 200,
        "question_description": "Given a grid of '1's and '0's, count the number of islands.",
        "examples": null,
        "constraints": "Islands are surrounded by water and are connected horizontally or vertically.",
        "solution_code": "class Solution(object):\n    def numIslands(self, grid):\n        rows, cols = len(grid), len(grid[0])\n        visited = set()  # To track visited cells\n\n        def dfs(x, y):\n            # Base case: Check bounds and if the cell is unvisited land (\"1\")\n            if (\n                x < 0 or x >= rows or y < 0 or y >= cols  # Out of bounds\n                or grid[x][y] != \"1\"                      # Not land\n                or (x, y) in visited                      # Already visited\n            ):\n                return\n            \n            # Mark the current cell as visited\n            visited.add((x, y))\n            dfs(x - 1, y)  # Up\n            dfs(x + 1, y)  # Down\n            dfs(x, y - 1)  # Left\n            dfs(x, y + 1)  # Right\n\n        count = 0\n\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == \"1\" and (i, j) not in visited:\n                    count += 1  # Found a new island\n                    dfs(i, j)   # Explore the island using DFS\n\n        return count\n"
    },
    {
        "question_number": 347,
        "question_description": "Return the k most frequent elements in an array.",
        "examples": null,
        "constraints": "You may assume that k is always valid.",
        "solution_code": "class Solution(object):\n    def topKFrequent(self, nums, k):\n\n        freq = Counter(nums)\n        heap = []\n\n        for num, freq in freq.items():\n            heapq.heappush(heap, (freq, num))\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return [num for freq, num in heap]\n        "
    },
    {
        "question_number": 670,
        "question_description": "Given a non-negative integer, swap two digits at most once to get the maximum valued number.",
        "examples": null,
        "constraints": "The integer must remain non-negative.",
        "solution_code": "class Solution(object):\n    def maximumSwap(self, num):\n        nums = list(str(num))\n        max_digit = -1\n        swap1 = -1\n        swap2 = -1\n\n        for i in range(len(nums) -1, -1 , -1):\n            # find largest number\n            if max_digit == -1 or nums[i] > nums[max_digit]:\n                max_digit = i\n            # find smaller number to the left\n            elif nums[i] < nums[max_digit]:\n                swap1 = i\n                swap2 = max_digit\n        if swap1 != -1 and swap2 != -1:\n            nums[swap1], nums[swap2] = nums[swap2], nums[swap1]\n        return int(\"\".join(nums))\n\n"
    },
    {
        "question_number": 15,
        "question_description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
        "examples": [
            {
                "input": {
                    "nums": [
                        -1,
                        0,
                        1,
                        2,
                        -1,
                        -4
                    ]
                },
                "output": [
                    [
                        -1,
                        -1,
                        2
                    ],
                    [
                        -1,
                        0,
                        1
                    ]
                ]
            }
        ],
        "constraints": "0 <= nums.length <= 3000, -10^5 <= nums[i] <= 10^5",
        "solution_code": "class Solution:\n    def threeSum(self, nums):\n        nums.sort()\n        res = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l + 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r - 1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res\n"
    },
    {
        "question_number": 23,
        "question_description": "Merge k sorted linked lists and return it as one sorted list.",
        "examples": [
            {
                "input": {
                    "lists": [
                        [
                            1,
                            4,
                            5
                        ],
                        [
                            1,
                            3,
                            4
                        ],
                        [
                            2,
                            6
                        ]
                    ]
                },
                "output": [
                    1,
                    1,
                    2,
                    3,
                    4,
                    4,
                    5,
                    6
                ]
            }
        ],
        "constraints": "k == lists.length, 0 <= k <= 10^4, 0 <= lists[i].length <= 500",
        "solution_code": "class Solution(object):\n    def mergeKLists(self, lists):\n \n        heap = []\n        # add head nodes \n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode(0)\n        curr = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n            curr.next = node\n            curr = curr.next\n\n            if node.next:\n                # move to next node of the popped one in list\n                heapq.heappush(heap, (node.next.val, i, node.next))\n        return dummy.next"
    },
    {
        "question_number": 199,
        "question_description": "Given the root of a binary tree, return the rightmost node at each level of the tree.",
        "examples": [
            {
                "input": {
                    "root": [
                        1,
                        2,
                        3,
                        null,
                        5,
                        null,
                        4
                    ]
                },
                "output": [
                    1,
                    3,
                    4
                ]
            }
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 100].",
        "solution_code": "from collections import deque\n\nclass Solution(object):\n    def rightSideView(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        \n        queue = deque([root])  # Queue for BFS\n        result = []\n\n        while queue:\n            n = len(queue)\n            for i in range(n):\n                node = queue.popleft()\n                \n                # Add the last node of the current level to the result\n                if i == n - 1:\n                    result.append(node.val)\n                \n                # Add children to the queue for the next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n        return result\n"
    },
    {
        "question_number": 973,
        "question_description": "Given an array of points and an integer k, return the k closest points to the origin.",
        "examples": [
            {
                "input": {
                    "points": [
                        [
                            1,
                            3
                        ],
                        [
                            -2,
                            2
                        ]
                    ],
                    "k": 1
                },
                "output": [
                    [
                        -2,
                        2
                    ]
                ]
            }
        ],
        "constraints": "1 <= k <= points.length <= 10^4",
        "solution_code": "import heapq\n\nclass Solution(object):\n    def kClosest(self, points, k):\n        \"\"\"\n        :type points: List[List[int]]\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        def squared_distance(point):\n            return point[0] ** 2 + point[1] ** 2\n\n        max_heap = []\n        for point in points:\n            heapq.heappush(max_heap, (-squared_distance(point), point))\n            # Maintain heap size of k\n            if len(max_heap) > k:\n                heapq.heappop(max_heap)  # Remove the farthest point\n        \n        return [point for _, point in max_heap]\n"
    },
    {
        "question_number": 986,
        "question_description": "Given two lists of intervals, return their intersection.",
        "examples": [
            {
                "input": {
                    "A": [
                        [
                            0,
                            2
                        ],
                        [
                            5,
                            10
                        ],
                        [
                            13,
                            23
                        ],
                        [
                            24,
                            25
                        ]
                    ],
                    "B": [
                        [
                            1,
                            5
                        ],
                        [
                            8,
                            12
                        ],
                        [
                            15,
                            24
                        ],
                        [
                            25,
                            26
                        ]
                    ]
                },
                "output": [
                    [
                        1,
                        2
                    ],
                    [
                        5,
                        5
                    ],
                    [
                        8,
                        10
                    ],
                    [
                        15,
                        23
                    ],
                    [
                        24,
                        24
                    ],
                    [
                        25,
                        25
                    ]
                ]
            }
        ],
        "constraints": "0 <= len(A), len(B) <= 1000",
        "solution_code": "class Solution(object):\n    def intervalIntersection(self, firstList, secondList):\n\n        res = []\n        i, j = 0, 0\n\n        while i < len(firstList) and j < len(secondList):\n            # Calculate the overlap\n            start = max(firstList[i][0], secondList[j][0])\n            end = min(firstList[i][1], secondList[j][1])\n\n            # If there's an overlap, add it to the result\n            if start <= end:\n                res.append([start, end])\n            \n            # Move the pointer of the interval that ends earlier\n            if firstList[i][1] < secondList[j][1]:\n                i += 1\n            else:\n                j += 1\n\n        return res\n"
    },
    {
        "question_number": 987,
        "question_description": "Given the root of a binary tree, return the vertical order traversal of its nodes' values.",
        "examples": null,
        "constraints": "None",
        "solution_code": "from collections import defaultdict, deque\n\nclass Solution(object):\n    def verticalTraversal(self, root):\n  \n        if not root:\n            return []\n\n        # Dictionary to store nodes by column index\n        col_dict = defaultdict(list)\n        \n        # BFS with (node, row, col)\n        queue = deque([(root, 0, 0)])\n        \n        while queue:\n            node, row, col = queue.popleft()\n            \n            if node:\n                col_dict[col].append((row, node.val))\n                \n                if node.left:\n                    queue.append((node.left, row + 1, col - 1))\n                if node.right:\n                    queue.append((node.right, row + 1, col + 1))\n        \n        # Sort the columns\n        result = []\n        for col in sorted(col_dict.keys()):\n            # Sort by row first, then by value\n            col_nodes = sorted(col_dict[col], key=lambda x: (x[0], x[1]))\n            result.append([val for row, val in col_nodes])\n        \n        return result\n"
    },
    {
        "question_number": 1004,
        "question_description": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's you can get by flipping at most k 0's.",
        "examples": [
            {
                "input": {
                    "nums": [
                        1,
                        1,
                        0,
                        0,
                        1,
                        1,
                        1,
                        0,
                        1
                    ],
                    "k": 2
                },
                "output": 6
            }
        ],
        "constraints": "1 <= nums.length <= 10^5, nums[i] is 0 or 1",
        "solution_code": "class Solution(object):\n    def longestOnes(self, nums, k):\n    \n        left = 0  # Left pointer for the sliding window\n\n        for right in range(len(nums)):  # Right pointer expands the window\n            # If the current element is 0, decrement k (use one flip)\n            if nums[right] == 0:\n                k -= 1\n\n            # If k is negative, move the left pointer to shrink the window\n            if k < 0:\n                if nums[left] == 0:\n                    k += 1  # Reclaim the flip\n                left += 1  # Move the left pointer\n\n        # The size of the largest valid window\n        return right - left + 1"
    },
    {
        "question_number": 1539,
        "question_description": "Given an array arr of positive integers sorted in a strictly increasing order, return the kth positive integer that is missing from this array.",
        "examples": [
            {
                "input": {
                    "arr": [
                        2,
                        3,
                        4,
                        7,
                        11
                    ],
                    "k": 5
                },
                "output": 9
            }
        ],
        "constraints": "1 <= arr.length <= 1000, 1 <= arr[i] <= 1000",
        "solution_code": "class Solution(object):\n    def findKthPositive(self, arr, k):\n        left, right = 0, len(arr) - 1\n\n        # Binary search to find the smallest index where the k-th missing lies\n        while left <= right:\n            mid = (left + right) // 2\n            # Calculate the number of missing numbers up to index mid\n            missing = arr[mid] - mid - 1\n\n            if missing < k:\n                # Not enough missing numbers, go right\n                left = mid + 1\n            else:\n                # Too many missing numbers, go left\n                right = mid - 1\n\n        # The k-th missing number\n        return left + k\n"
    },
    {
        "question_number": 34,
        "question_description": "Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.",
        "examples": [
            {
                "input": {
                    "nums": [
                        5,
                        7,
                        7,
                        8,
                        8,
                        10
                    ],
                    "target": 8
                },
                "output": [
                    3,
                    4
                ]
            }
        ],
        "constraints": "0 <= nums.length <= 10^5",
        "solution_code": "class Solution(object):\n    def searchRange(self, nums, target):\n\n        def first(nums):\n            l = 0\n            r = len(nums) - 1\n            temp = -1\n            while (l <= r):\n                mid = (l + r) // 2\n                if nums[mid] == target:\n                    temp = mid  # found an instance\n                    r = mid - 1 # find more on the left\n                elif nums[mid] > target:\n                    r = mid - 1\n                else:\n\n                    l = mid + 1\n            return temp\n        \n        def last(nums):\n            l = 0\n            r = len(nums) - 1\n            temp = -1\n            while (l <= r):\n                mid = (l + r) // 2\n                if nums[mid] == target:\n                    temp = mid  # found an instance\n                    l = mid + 1 # find more on the right\n                elif nums[mid] > target:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n            return temp\n        \n        return [first(nums), last(nums)]"
    },
    {
        "question_number": 129,
        "question_description": "Given the root of a binary tree, return the sum of all root-to-leaf numbers.",
        "examples": [
            {
                "input": {
                    "root": [
                        1,
                        2,
                        3
                    ]
                },
                "output": 25
            }
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 1000].",
        "solution_code": "from collections import deque\n\nclass Solution(object):\n    def sumNumbers(self, root):\n\n        if not root:\n            return 0\n\n        total_sum = 0\n        queue = deque([(root, root.val)])  # Store (node, current_number)\n\n        while queue:\n            curr, num = queue.popleft()\n\n            # If it's a leaf node, add the number to total_sum\n            if not curr.left and not curr.right:\n                total_sum += num\n\n            # If the node has a left child, append it to the queue with the updated number\n            if curr.left:\n                queue.append((curr.left, num * 10 + curr.left.val))\n\n            # If the node has a right child, append it to the queue with the updated number\n            if curr.right:\n                queue.append((curr.right, num * 10 + curr.right.val))\n\n        return total_sum\n"
    },
    {
        "question_number": 249,
        "question_description": "Given a list of strings, group all strings that belong to the same shifting sequence.",
        "examples": null,
        "constraints": "All strings have lowercase English letters.",
        "solution_code": "class Solution(object):\n    def groupStrings(self, strings):\n        \"\"\"\n        :type strings: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        seen = defaultdict(list) # pattern -> list\n\n        def pattern(s):\n            res = []\n            for i in range(len(s) - 1):\n                diff = ord(s[i + 1]) - ord(s[i])\n                shift = diff % 26\n                res.append(shift)\n            return tuple(res)\n\n        for s in strings:\n            final = pattern(s)\n            seen[final].append(s)\n        return seen.values()"
    },
    {
        "question_number": 480,
        "question_description": "Given an array of numbers and a sliding window size k, return the median of each window.",
        "examples": null,
        "constraints": "The array length and window size can be large.",
        "solution_code": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        min_heap = []   # for larger half\n        max_heap = []   # for smaller half\n        \n        def add(num):\n            # add to either max or min heap\n            if not max_heap or num <= -max_heap[0]:\n                heapq.heappush(max_heap, -num)\n            else:\n                heapq.heappush(min_heap, num)\n            balance()\n\n        def remove(num):\n            # find heap to remove from\n            if num <= -max_heap[0]:\n                max_heap.remove(-num)\n                heapify(max_heap)\n            else:\n                min_heap.remove(num)\n                heapify(min_heap)\n            balance()\n\n        # ensures that heaps are the same size\n        def balance():\n            while len(max_heap) > len(min_heap) + 1:\n                heapq.heappush(min_heap, -heapq.heappop(max_heap))\n            while len(min_heap) > len(max_heap):\n                heapq.heappush(max_heap, -heapq.heappop(min_heap))\n        \n        def getMedian():\n            if len(max_heap) > len(min_heap):\n                return -max_heap[0]\n            return (-max_heap[0] + min_heap[0]) / 2.0\n\n        res = []\n        for i in range(len(nums)):\n            add(nums[i])\n            if i >= k - 1:\n                res.append(getMedian())\n                remove(nums[i - k + 1])\n        return res"
    },
    {
        "question_number": 539,
        "question_description": "Given a list of 24-hour clock time points, find the minimum minutes difference between any two time points.",
        "examples": null,
        "constraints": "Each time point is in HH:MM format.",
        "solution_code": "class Solution(object):\n    def findMinDifference(self, timePoints):\n        \"\"\"\n        :type timePoints: List[str]\n        :rtype: int\n        \"\"\"\n        # time since midnight\n        def timeSince(thing):\n            hours, mins = thing.split(':')\n            return int(hours) * 60 + int(mins)\n\n        sortedList = sorted(timeSince(x) for x in timePoints)\n\n        diff = float('inf')\n\n        for i in range(len(sortedList) - 1):\n            diff = min(diff, abs(sortedList[i] - sortedList[i + 1]))\n        \n        row = 1440 - sortedList[-1] + sortedList[0]\n        diff = min(diff, row)\n        return diff"
    },
    {
        "question_number": 791,
        "question_description": "Given two strings order and str, sort the characters of str by the order defined in order.",
        "examples": null,
        "constraints": "All characters in order are unique.",
        "solution_code": "class Solution(object):\n    def customSortString(self, order, s):\n\n        freq = Counter(s)\n\n        res = []\n\n        # go thru the correct order\n        for c in order:\n            while freq[c] > 0:\n                res.append(c)\n                freq[c] -= 1\n        # add remaining not in order\n        for key in freq:\n            while freq[key] > 0:\n                res.append(key)\n                freq[key] -= 1\n        return \"\".join(res)"
    },
    {
        "question_number": 938,
        "question_description": "Given the root of a BST and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].",
        "examples": null,
        "constraints": "The number of nodes in the tree is in the range [1, 2 * 10^4].",
        "solution_code": "class Solution(object):\n    def rangeSumBST(self, root, low, high):\n        \n        def dfs(node):\n            if not node:\n                return\n            if low <= node.val <= high:\n                self.count += node.val\n            \n            if node.left and node.val > low:\n                dfs(node.left)\n            if node.right and node.val < high:\n                dfs(node.right)\n        self.count = 0\n        dfs(root)\n        \n        return self.count"
    },
    {
        "question_number": 1,
        "question_description": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.",
        "examples": null,
        "constraints": "Each input would have exactly one solution.",
        "solution_code": "class Solution(object):\n    def twoSum(self, nums, target):\n\n        mine = defaultdict(int)\n\n        for i, n in enumerate(nums):\n            if n in mine:\n                return [mine[n], i]\n            mine[target-  n] = i\n        return [-1,-1]"
    },
    {
        "question_number": 20,
        "question_description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
        "examples": null,
        "constraints": "The input string only contains valid characters.",
        "solution_code": "class Solution(object):\n    def isValid(self, s):\n\n        # Mapping of closing brackets to their corresponding opening brackets\n        matching_brackets = {\n            \")\": \"(\",\n            \"}\": \"{\",\n            \"]\": \"[\"\n        }\n\n        # Stack to keep track of unmatched opening brackets\n        stack = []\n\n        for char in s:\n            # If the character is a closing bracket\n            if char in matching_brackets:\n                # Check if the stack is empty or the top doesn't match\n                if not stack or stack.pop() != matching_brackets[char]:\n                    return False\n            else:\n                # If it's an opening bracket, push it onto the stack\n                stack.append(char)\n\n        # If the stack is empty, all brackets are matched and valid\n        return not stack"
    },
    {
        "question_number": 121,
        "question_description": "Given an array prices where prices[i] is the price of a given stock on day i, find the maximum profit you can achieve.",
        "examples": null,
        "constraints": "You may not engage in multiple transactions at the same time.",
        "solution_code": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n\n        l = 0  # our buy, r is out sell\n        best = 0  \n\n        for r in range(1, len(prices)):\n            if prices[r] < prices[l]:\n                l = r\n            else:\n                curr = prices[r] - prices[l]\n                best = max(curr, best)\n\n        return best\n"
    },
    {
        "question_number": 346,
        "question_description": "Given a stream of integers, calculate the moving average of all integers in the sliding window.",
        "examples": null,
        "constraints": "Each integer in the data stream is assumed to be a 32-bit integer.",
        "solution_code": "from collections import deque\n\nclass MovingAverage:\n    def __init__(self, size):\n        self.size = size\n        self.queue = deque()\n        self.window_sum = 0\n        self.count = 0\n\n    def next(self, val):\n        self.count += 1\n        # Calculate the new sum by shifting the window\n        self.queue.append(val)\n        tail = self.queue.popleft() if self.count > self.size else 0\n\n        self.window_sum = self.window_sum - tail + val\n\n        # Ensure the result is a float by casting the numerator to float\n        return float(self.window_sum) / min(self.size, self.count)\n"
    },
    {
        "question_number": 636,
        "question_description": "Return the exclusive time of each function, given the function logs.",
        "examples": null,
        "constraints": "Assume the input is always valid.",
        "solution_code": "class Solution(object):\n    def exclusiveTime(self, n, logs):\n        \"\"\"\n        :type n: int\n        :type logs: List[str]\n        :rtype: List[int]\n        \"\"\"\n        res = [0] * n # for each function\n        stack = [] # keep tracking of running function\n        prev = 0\n\n        for log in logs:\n            func, event, timestamp = log.split(\":\")\n            func = int(func)\n            timestamp = int(timestamp)\n\n            if event == \"start\":\n                # If a function is currently running, update its exclusive time\n                if stack:\n                    res[stack[-1]] += timestamp - prev\n                # Start the current function by pushing it onto the stack\n                stack.append(func)\n                prev = timestamp\n            else:\n                # Add the time of the function that just finished\n                res[stack.pop()] += timestamp - prev + 1\n                prev = timestamp + 1\n        return res"
    },
    {
        "question_number": 426,
        "question_description": "Convert a binary search tree to a sorted circular doubly-linked list in-place.",
        "examples": null,
        "constraints": "The number of nodes is in the range [0, 2000].",
        "solution_code": "\nclass Solution(object):\n    def treeToDoublyList(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        \n        # in  order traversal\n        # left work right\n\n        self.prev = None\n        self.head = None\n        def dfs(node):\n            if not node:\n                return\n            \n            dfs(node.left)\n            # work\n            if not self.prev:\n                self.head = node\n                \n            else:\n                self.prev.right = node\n                node.left = self.prev\n            self.prev = node\n\n            \n            dfs(node.right)\n            \n        if not root:\n            return None\n        dfs(root)\n        self.prev.right = self.head\n        self.head.left = self.prev\n        return self.head"
    },
    {
        "question_number": 708,
        "question_description": "Insert a value into a sorted circular linked list.",
        "examples": null,
        "constraints": "Each node has a single next pointer and the list is circular.",
        "solution_code": "class Solution(object):\n    def insert(self, head, insertVal):\n \n        # Case 1:\n        if not head:\n            temp = Node(insertVal)\n            temp.next = temp  # Circular reference\n            return temp\n\n        # Case 2: If there is only one node\n        if head.next == head:\n            head.next = Node(insertVal)\n            head.next.next = head  # Complete the circular link\n            return head\n\n \n        curr = head\n        while True:\n            # Case 3: Insert in the middle of the list\n            if curr.val <= insertVal <= curr.next.val:\n                break\n\n            # Case 4: Handle boundary conditions\n            # When the circular list reaches the boundary\n            if curr.val > curr.next.val:  \n                if insertVal >= curr.val or insertVal <= curr.next.val:\n                    break\n\n            curr = curr.next\n\n            # Case 5: If we complete a full circle \n            if curr == head:\n                break\n\n        res = Node(insertVal)\n        last = curr.next\n        curr.next = res\n        res.next = last\n        return head\n"
    },
    {
        "question_number": 1047,
        "question_description": "Remove all adjacent duplicates in a string using stack-like behavior.",
        "examples": null,
        "constraints": "The string length is at most 10^5.",
        "solution_code": "class Solution(object):\n    def removeDuplicates(self, s):\n     \n        stack = []  # Use a stack to track non-duplicate characters\n\n        for char in s:\n            # If the top matches the current character, pop it\n            if stack and stack[-1] == char:\n                stack.pop()\n            else:\n                stack.append(char)  # add the current character to the stack\n\n        return \"\".join(stack)  \n"
    },
    {
        "question_number": 14,
        "question_description": "Find the longest common prefix string amongst an array of strings.",
        "examples": null,
        "constraints": "All input strings are lowercase and non-empty.",
        "solution_code": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n \n        if not strs:\n            return \"\"  \n\n        prefix = strs[0]\n        \n        for s in strs[1:]:\n            # Reduce the prefix\n            while not s.startswith(prefix):\n                prefix = prefix[:-1]  # Shorten the prefix\n                if not prefix:\n                    return \"\"  # No common prefix\n        \n        return prefix"
    },
    {
        "question_number": 17,
        "question_description": "Return all possible letter combinations that the number could represent.",
        "examples": null,
        "constraints": "The input is a string containing digits from 2-9 inclusive.",
        "solution_code": "class Solution(object):\n    def letterCombinations(self, digits):\n  \n        if not digits:\n            return []\n\n        letters = {\n            \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\",\n            \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\"\n        }\n\n        def backtrack(index, path):\n            # Base case: if the combination is complete\n            if index == len(digits):\n                res.append(\"\".join(path))\n                return\n            \n            # Get possible letters for the current digit\n            for char in letters[digits[index]]:\n                path.append(char)\n                backtrack(index + 1, path)\n                path.pop()  # Backtrack\n\n        res = []\n        backtrack(0, [])\n        return res\n"
    },
    {
        "question_number": 76,
        "question_description": "Given two strings s and t, return the minimum window in s which will contain all the characters in t.",
        "examples": null,
        "constraints": "If there is no such window in s, return the empty string.",
        "solution_code": "class Solution(object):\n    def minWindow(self, s, t):\n     \n        # s represents the full string\n        # t represent the dictionary one\n\n        t_count = Counter(t)\n        n = len(t_count)\n\n        l = 0\n        r = 0\n\n        seen_count = defaultdict(int)\n\n        while r < len(s):\n            curr = s[r]\n            count[curr] += 1\n\n            if curr in t_count and count[curr] == t_count[curr]:\n                \n\n"
    },
    {
        "question_number": 179,
        "question_description": "Given a list of non-negative integers, arrange them to form the largest number.",
        "examples": null,
        "constraints": "The result should not contain leading zeros.",
        "solution_code": "class Solution(object):\n    def largestNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: str\n        \"\"\"\n        num_str = [str(num) for num in nums]\n\n        num_str.sort(cmp = lambda x, y: cmp(x +y, y + x), reverse = True)\n        #num_str.sort(key = lambda a: a * 10, reverse = True)\n    \n        if num_str[0] == \"0\":\n            return \"0\"\n\n        return \"\".join(num_str)\n"
    },
    {
        "question_number": 198,
        "question_description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed.",
        "examples": null,
        "constraints": "You may not rob two adjacent houses.",
        "solution_code": "class Solution(object):\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        prev2 = 0  # Equivalent to dp[i-2]\n        prev1 = 0  # Equivalent to dp[i-1]\n\n        for num in nums:\n            # Current maximum money robbed\n            curr = max(prev2 + num, prev1)\n            prev2 = prev1\n            prev1 = curr\n\n        return prev1\n"
    },
    {
        "question_number": 392,
        "question_description": "Given two strings s and t, check if s is a subsequence of t.",
        "examples": null,
        "constraints": "Both s and t consist only of lowercase English letters.",
        "solution_code": "class Solution(object):\n    def isSubsequence(self, s, t):\n\n        if not s:\n            return True\n        if not t:\n            return False\n        l = 0  # for s\n        r = 0  # for t\n\n        while l < len(s) and r < len(t):\n            if s[l] == t[r]:  # Match found\n                l += 1\n            r += 1  # Move t pointer regardless of a match\n\n        return l == len(s) "
    },
    {
        "question_number": 398,
        "question_description": "Given an array of integers with possible duplicates, randomly return an index of the given target number.",
        "examples": null,
        "constraints": "The target number exists in the array.",
        "solution_code": "class Solution(object):\n\n    def __init__(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        \"\"\"\n        self.indices = defaultdict(list)\n        # maps num -> list of indexes\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        :type target: int\n        :rtype: int\n        \"\"\"\n        return random.choice(self.indices[target])\n        "
    },
    {
        "question_number": 498,
        "question_description": "Given an m x n matrix, return an array of all the elements of the matrix in a diagonal order.",
        "examples": [
            {
                "input": {
                    "matrix": [
                        [
                            1,
                            2,
                            3
                        ],
                        [
                            4,
                            5,
                            6
                        ],
                        [
                            7,
                            8,
                            9
                        ]
                    ]
                },
                "output": [
                    1,
                    2,
                    4,
                    7,
                    5,
                    3,
                    6,
                    8,
                    9
                ]
            }
        ],
        "constraints": "m == matrix.length, n == matrix[i].length, 1 <= m, n <= 10^4",
        "solution_code": "class Solution(object):\n    def findDiagonalOrder(self, mat):\n        row, col = 0, 0\n        direction = 1  # 1 for upward, -1 for downward\n        N, M = len(mat), len(mat[0])\n        res = []\n\n        while row < N and col < M:\n            res.append(mat[row][col])\n\n            # Calculate the next position\n            new_row = row + (-1 if direction == 1 else 1)\n            new_col = col + (1 if direction == 1 else -1)\n\n            # Check if the new position is out of bounds\n            if new_row < 0 or new_row >= N or new_col < 0 or new_col >= M:\n                if direction == 1:  # Moving upward\n                    # If we hit the last column, move down\n                    if col == M - 1:\n                        row += 1\n                    # Otherwise, move to the next column\n                    else:\n                        col += 1\n                else:  # Moving downward\n                    # If we hit the last row, move right\n                    if row == N - 1:\n                        col += 1\n                    # Otherwise, move to the next row\n                    else:\n                        row += 1\n                # Change direction\n                direction = -direction\n            else:\n                # Move to the next position\n                row = new_row\n                col = new_col\n\n        return res\n"
    },
    {
        "question_number": 721,
        "question_description": "Given a list of accounts, merge the accounts with common emails.",
        "examples": [
            {
                "input": {
                    "accounts": [
                        [
                            "John",
                            "johnsmith@mail.com",
                            "john00@mail.com"
                        ],
                        [
                            "John",
                            "johnnybravo@mail.com"
                        ],
                        [
                            "John",
                            "johnsmith@mail.com",
                            "john_newyork@mail.com"
                        ],
                        [
                            "Mary",
                            "mary@mail.com"
                        ]
                    ]
                },
                "output": [
                    [
                        "John",
                        "john00@mail.com",
                        "john_newyork@mail.com",
                        "johnsmith@mail.com"
                    ],
                    [
                        "John",
                        "johnnybravo@mail.com"
                    ],
                    [
                        "Mary",
                        "mary@mail.com"
                    ]
                ]
            }
        ],
        "constraints": "1 <= accounts.length <= 1000",
        "solution_code": "from collections import defaultdict\n\nclass Solution(object):\n    def accountsMerge(self, accounts):\n\n        # Build graph\n        email_graph = defaultdict(set)\n        email_to_name = {}\n\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n\n            for email in acc[1:]:\n                email_graph[first_email].add(email)\n                email_graph[email].add(first_email)\n                email_to_name[email] = name\n\n        # Depth-First Search function\n        def dfs(email, connected_emails):\n            # Mark the email as visited\n            visited.add(email)\n            # Add the current email to the connected component\n            connected_emails.append(email)\n            # Visit all neighbors (connected emails) recursively\n            for neighbor in email_graph[email]:\n                if neighbor not in visited:\n                    dfs(neighbor, connected_emails)\n\n        # Perform DFS for all emails\n        visited = set()\n        res = []\n\n        for email in email_graph:\n            if email not in visited:\n                # Initialize a new connected component\n                connected_emails = []\n                # Perform DFS to gather all emails in the same component\n                dfs(email, connected_emails)\n                # Sort the emails and add the name at the front\n                res.append([email_to_name[email]] + sorted(connected_emails))\n\n        return res\n"
    },
    {
        "question_number": 827,
        "question_description": "Given a binary matrix, return the size of the largest island by flipping one 0 to 1.",
        "examples": [
            {
                "input": {
                    "grid": [
                        [
                            1,
                            0
                        ],
                        [
                            0,
                            1
                        ]
                    ]
                },
                "output": 3
            }
        ],
        "constraints": "n == grid.length == grid[i].length, 1 <= n <= 500",
        "solution_code": "class Solution(object):\n    def largestIsland(self, grid):\n  \n        n = len(grid)\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        island_area = {}  # Map of island_id -> area\n        \n        def dfs(x, y, island_id):\n            # Boundary check and if already visited or water\n            if x < 0 or x >= n or y < 0 or y >= n or grid[x][y] != 1:\n                return 0\n            grid[x][y] = island_id  # Mark cell with its island ID\n            area = 1\n            for dx, dy in directions:\n                area += dfs(x + dx, y + dy, island_id)\n            return area\n\n        # Step 1: Identify islands and calculate their areas\n        island_id = 2\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    island_area[island_id] = dfs(i, j, island_id)\n                    island_id += 1\n        \n        # Step 2: Attempt to flip each `0` and calculate the largest possible island\n        max_area = max(island_area.values()) if island_area else 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    seen = set()\n                    new_area = 1  # Include the flipped cell\n                    for dx, dy in directions:\n                        ni, nj = i + dx, j + dy\n                        if 0 <= ni < n and 0 <= nj < n and grid[ni][nj] > 1:\n                            neighbour_id = grid[ni][nj]\n                            if neighbour_id not in seen:\n                                new_area += island_area[neighbour_id]\n                                seen.add(neighbour_id)\n                    max_area = max(max_area, new_area)\n        \n        return max_area\n"
    },
    {
        "question_number": 875,
        "question_description": "Given piles of bananas and an integer H, return the minimum integer K such that Koko can eat all the bananas within H hours.",
        "examples": [
            {
                "input": {
                    "piles": [
                        3,
                        6,
                        7,
                        11
                    ],
                    "H": 8
                },
                "output": 4
            }
        ],
        "constraints": "1 <= piles.length <= 10^4",
        "solution_code": "class Solution(object):\n    def minEatingSpeed(self, piles, h):\n        \n        l = 1  # Minimum possible speed\n        r = max(piles)  # Maximum possible speed\n\n        while l < r:\n            curr = (l + r) // 2  # Current speed to test\n            hours_pass = 0\n\n            for p in piles:\n                # Use integer arithmetic to calculate the ceiling of p / curr\n                hours_pass += (p + curr - 1) // curr\n            \n            if hours_pass <= h:\n                # If the current speed allows Koko to finish within h hours, it's feasible\n                r = curr\n            else:\n                # Otherwise, try a higher speed\n                l = curr + 1\n\n        return l  # Minimum speed found\n"
    },
    {
        "question_number": 1371,
        "question_description": "Given a string, return the length of the longest substring containing even counts of vowels.",
        "examples": [
            {
                "input": {
                    "s": "eleetminicoworoep"
                },
                "output": 13
            }
        ],
        "constraints": "s consists of lowercase English letters",
        "solution_code": "class Solution:\n    def findTheLongestSubstring(self, s):\n  \n        # Initialize prefixXOR to track the parity of vowels\n        prefixXOR = 0\n\n        # Create a character-to-bitmask mapping for vowels\n        characterMap = [0] * 26\n        characterMap[ord(\"a\") - ord(\"a\")] = 1    # 00001\n        characterMap[ord(\"e\") - ord(\"a\")] = 2    # 00010\n        characterMap[ord(\"i\") - ord(\"a\")] = 4    # 00100\n        characterMap[ord(\"o\") - ord(\"a\")] = 8    # 01000\n        characterMap[ord(\"u\") - ord(\"a\")] = 16   # 10000\n\n        # Create a map to store the first occurrence of each prefixXOR value\n        # Size is 32 (2^5 for all possible combinations of vowel parities)\n        # Initialize all positions to -1 to represent \"not seen\"\n        mp = [-1] * 32\n\n        longestSubstring = 0\n        for i in range(len(s)):\n            # toggle respective bit\n            prefixXOR ^= characterMap[ord(s[i]) - ord(\"a\")]\n            if mp[prefixXOR] == -1 and prefixXOR != 0:\n                mp[prefixXOR] = i\n            longestSubstring = max(longestSubstring, i - mp[prefixXOR])\n        return longestSubstring\n"
    },
    {
        "question_number": 4,
        "question_description": "Given two sorted arrays, return the median of the two arrays.",
        "examples": [
            {
                "input": {
                    "nums1": [
                        1,
                        3
                    ],
                    "nums2": [
                        2
                    ]
                },
                "output": 2.0
            }
        ],
        "constraints": "0 <= nums1.length, nums2.length <= 1000",
        "solution_code": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        nums = nums1 + nums2\n        # Sort the combined array\n        nums.sort()\n\n        n = len(nums)\n        # Check if the length of combined array is odd\n        if n % 2 == 1:\n            # Return middle element\n            return float(nums[n // 2])\n        else:\n            # Return average of two middle elements\n            return (nums[n // 2 - 1] + nums[n // 2]) / 2.0"
    },
    {
        "question_number": 5,
        "question_description": "Given a string s, return the longest palindromic substring.",
        "examples": [
            {
                "input": {
                    "s": "babad"
                },
                "output": "bab"
            }
        ],
        "constraints": "1 <= s.length <= 1000",
        "solution_code": "class Solution(object):\n    def longestPalindrome(self, s):\n  \n        # Transform the string to avoid even-length palindromes\n        t = '#' + '#'.join(s) + '#'\n        n = len(t)\n        P = [0] * n  # Array to store the radius of the palindrome at each character\n        C = R = 0  # Center and right boundary of the rightmost palindrome found\n        \n        for i in range(n):\n            mirror = 2 * C - i  # Find the mirror of the current position i\n            \n            # If within the range of the current right boundary, use the mirror's value\n            if i < R:\n                P[i] = min(R - i, P[mirror])\n            \n            # Attempt to expand the palindrome centered at i\n            while i + P[i] + 1 < n and i - P[i] - 1 >= 0 and t[i + P[i] + 1] == t[i - P[i] - 1]:\n                P[i] += 1\n            \n            # Update the center and right boundary if the palindrome expands beyond R\n            if i + P[i] > R:\n                C, R = i, i + P[i]\n        \n        # Find the maximum palindrome in P\n        max_len, center_index = max((n, i) for i, n in enumerate(P))\n        start = (center_index - max_len) // 2  # Map back to the original string\n        \n        return s[start:start + max_len]"
    },
    {
        "question_number": 7,
        "question_description": "Given a signed 32-bit integer, return the integer reversed.",
        "examples": [
            {
                "input": {
                    "x": 123
                },
                "output": 321
            }
        ],
        "constraints": "-2^31 <= x <= 2^31 - 1",
        "solution_code": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        # Reverse the string of the absolute value of x\n        reversed_int = int(str(abs(x))[::-1])\n        \n        # Restore the sign\n        if x < 0:\n            reversed_int = -reversed_int\n        \n        # Check for 32-bit signed integer overflow\n        if reversed_int < -2**31 or reversed_int > 2**31 - 1:\n            return 0\n        \n        return reversed_int\n"
    },
    {
        "question_number": 8,
        "question_description": "Convert a string to an integer, following specific rules for whitespace, optional +/- sign, and overflow.",
        "examples": [
            {
                "input": {
                    "s": "42"
                },
                "output": 42
            }
        ],
        "constraints": "s consists of printable ASCII characters",
        "solution_code": "class Solution(object):\n    def myAtoi(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        INT_MAX = 2**31 - 1  # 2147483647\n        INT_MIN = -2**31     # -2147483648\n        index = 0\n        sign = 1\n        n = len(s)\n        res = 0\n\n        while index < n and s[index] == ' ':\n            index += 1\n\n        # sign\n        if index < n and (s[index] == '+' or s[index] == '-'):\n            sign = -1 if s[index] == '-' else 1\n            index += 1\n\n        # convert \n        while index < n and s[index].isdigit():\n            digit = int(s[index])\n\n            if res > (INT_MAX - digit) // 10:\n                return INT_MAX if sign == 1 else INT_MIN\n            res = res * 10 + digit\n            index += 1\n        return sign * res"
    },
    {
        "question_number": 44,
        "question_description": "Implement wildcard pattern matching with support for '?' and '*'.",
        "examples": [
            {
                "input": {
                    "s": "aa",
                    "p": "a"
                },
                "output": false
            }
        ],
        "constraints": "0 <= s.length, p.length <= 2000",
        "solution_code": "class Solution(object):\n    def isMatch(self, s, p):\n    \n        s_len = len(s)\n        p_len = len(p)\n\n        s_index = 0\n        p_index = 0\n\n        star_index = -1\n        match_index = -1\n\n        while s_index < s_len:\n            # case 1 exact character match \n            if p_index < p_len and p[p_index] == s[s_index]:\n                s_index += 1\n                p_index += 1\n            # case 2 ? match any character\n            elif p_index < p_len and p[p_index] == '?':\n                s_index += 1\n                p_index += 1\n            # case 3 * matches any sequence\n            elif p_index < p_len and p[p_index] == '*':\n                star_index = p_index\n                match_index = s_index\n                p_index += 1\n            # case 4 mismatch but we had a * to backtrack\n            elif star_index != -1:\n                p_index = star_index + 1\n                match_index += 1\n                s_index = match_index\n\n            # case 5 no match and no *\n            else:\n                return False\n\n        # Check for remaining '*' in the pattern or all * case\n        while p_index < p_len and p[p_index] == '*':\n            p_index += 1\n        return p_index == p_len"
    },
    {
        "question_number": 128,
        "question_description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence.",
        "examples": null,
        "constraints": "Your algorithm should run in O(n) complexity.",
        "solution_code": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not nums:\n            return 0\n\n        mine = set(nums)\n        most = 1\n        for n in mine:\n            if n - 1 in mine:\n                continue\n            else:\n                count = 1\n                while n + 1 in mine:    \n                    count += 1\n                    most = max(count, most)\n                    n += 1\n        return most"
    },
    {
        "question_number": 207,
        "question_description": "Determine if you can finish all courses given the prerequisites.",
        "examples": null,
        "constraints": "Assume the graph has no cycles.",
        "solution_code": "class Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        adj_list = defaultdict(list)\n        in_degree = [0] * numCourses\n\n\n        # create our adj list\n        for dest, src in prerequisites:\n            adj_list[src].append(dest)\n            in_degree[dest] += 1\n        \n        # start our queue with courses wtih no prereqs\n        queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n        courses_taken = 0\n\n        # simlute going thru course in order\n        while queue:\n            course = queue.popleft()\n            courses_taken += 1\n            \n            for neighbor in adj_list[course]:\n                in_degree[neighbor] -= 1    # say we took the prereq\n                if in_degree[neighbor] == 0:    # check if we have taken all prereqs and can now take the course\n                    queue.append(neighbor)\n        \n        return courses_taken == numCourses  # check if our siluariton matches the expected\n\n        "
    },
    {
        "question_number": 270,
        "question_description": "Given a target value and a binary search tree, find the value in the BST that is closest to the target.",
        "examples": null,
        "constraints": "The target value is a floating-point number.",
        "solution_code": "class Solution(object):\n    def closestValue(self, root, target):\n \n        \n        close = float('inf')\n\n        queue = deque([root])\n        \n        while (queue):\n            curr = queue.pop()\n            if not curr:\n                continue\n            if ( abs(curr.val - target) <= abs(close - target)):\n                if ( abs(curr.val - target) == abs(close - target)):\n                    close = min(close, curr.val)\n                else:\n                    close = curr.val\n\n            if curr.val < target:\n                queue.append(curr.right)\n            elif curr.val > target:\n                queue.append(curr.left)\n        return close"
    },
    {
        "question_number": 278,
        "question_description": "Given n versions, find the first bad version using the isBadVersion API.",
        "examples": null,
        "constraints": "Assume all versions after a bad version are also bad.",
        "solution_code": "class Solution(object):\n    def firstBadVersion(self, n):\n  \n        l = 0\n        r = n\n        while l < r:\n            mid = (l + r) // 2\n            if isBadVersion(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return r"
    },
    {
        "question_number": 282,
        "question_description": "Given a string num and a target, add operators +, -, or * between digits to reach the target value.",
        "examples": null,
        "constraints": "Assume all given numbers are positive.",
        "solution_code": "class Solution(object):\n    def addOperators(self, num, target):\n       \n        res = []\n\n        def backtrack(index, exp, prev, curr):\n            if index == len(num):\n                if curr == target:\n                    res.append(exp)\n                return \n            \n            # try all\n            for i in range(index, len(num)):\n                if i > index and num[index] == \"0\":\n                    break\n                curr_op = int(num[index: i + 1])\n                curr_str = num[index:i + 1]\n\n                if index == 0:\n                    backtrack(i + 1, curr_str, curr_op, curr_op)\n                else:\n                    # ADD '+'\n                    backtrack(i + 1, exp + \"+\" + curr_str, curr_op, curr + curr_op)\n                    # ADD '-'\n                    backtrack(i + 1, exp + \"-\" + curr_str, -curr_op, curr - curr_op)\n                    # ADD '*'\n                    backtrack(i + 1, exp + \"*\" + curr_str, prev * curr_op, curr - prev + (prev * curr_op))\n            \n        backtrack(0,\"\", 0,0)\n        return res"
    },
    {
        "question_number": 348,
        "question_description": "Design a Tic-Tac-Toe game that can be played by two players.",
        "examples": null,
        "constraints": "Assume players always play valid moves.",
        "solution_code": "class TicTacToe(object):\n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.n = n\n        self.rows = [0] * n\n        self.cols = [0] * n\n        self.diag = 0\n        self.otherDiag = 0\n\n    def move(self, row, col, player):\n        \"\"\"\n        :type row: int\n        :type col: int\n        :type player: int\n        :rtype: int\n        \"\"\"\n        inc = 1 if player == 1 else - 1\n\n        self.rows[row] += inc\n        self.cols[col] += inc\n\n        if row == col:\n            self.diag += inc\n        if row + col == self.n - 1:\n            self.otherDiag += inc\n        \n        if (abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n or abs(self.diag) == self.n or abs(self.otherDiag) == self.n):\n            return 1 if inc == 1 else 2\n        return 0\n\n"
    },
    {
        "question_number": 350,
        "question_description": "Return an array of the intersection of two arrays, allowing duplicate elements.",
        "examples": null,
        "constraints": "The output can be in any order.",
        "solution_code": "from collections import Counter\n\nclass Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        mine = Counter(nums1)\n\n        for n in nums2:\n            if mine[n] > 0:  # Ensure count is positive\n                res.append(n)\n                mine[n] -= 1  # Decrement the count\n\n        return res\n"
    },
    {
        "question_number": 523,
        "question_description": "Given an integer array nums, return true if the array has a subarray with a sum that is a multiple of k.",
        "examples": null,
        "constraints": "The integer k is a positive integer.",
        "solution_code": "class Solution(object):\n    def checkSubarraySum(self, nums, k):\n        \n        if len(nums) == 1:\n            return False\n        # uses prefix sum\n        seen = {}\n        seen[0] = -1 # if the sum = 0\n        prefix = 0\n        for i, n in enumerate(nums):\n            prefix += n\n            prefix = prefix % k\n\n            if prefix in seen:\n                if i - seen[prefix] > 1 :\n                    return True\n            else:\n                seen[prefix] = i\n        return False\n"
    },
    {
        "question_number": 691,
        "question_description": "Given a collection of stickers, determine the minimum number of stickers to spell out a target word.",
        "examples": null,
        "constraints": "Each sticker and target contains only lowercase letters.",
        "solution_code": "hard.."
    },
    {
        "question_number": 824,
        "question_description": "A sentence S is given, convert each word to Goat Latin.",
        "examples": [
            {
                "input": {
                    "sentence": "I speak Goat Latin"
                },
                "output": "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"
            }
        ],
        "constraints": "1 <= S.length <= 150",
        "solution_code": "class Solution(object):\n    def toGoatLatin(self, sentence):\n        # Initialize a list to store the transformed words\n        end = []\n\n        # Split the input sentence into a list of words\n        sen = sentence.split()\n\n        # Iterate over the words along with their index\n        for i, word in enumerate(sen):\n            # Check if the first letter of the word is a vowel\n            if word[0].lower() in \"aeiou\":\n                # If it's a vowel, append \"ma\" to the word\n                trans = word + \"ma\"\n            else:\n                # If it's not a vowel, move the first letter to the end and append \"ma\"\n                trans = word[1:] + word[0] + \"ma\"\n\n            # Append 'a' repeated (i + 1) times based on the word's position in the sentence\n            trans += \"a\" * (i + 1)\n\n            # Add the transformed word to the result list\n            end.append(trans)\n\n        # Join all transformed words with a space and return the result\n        return \" \".join(end)\n"
    },
    {
        "question_number": 934,
        "question_description": "Given a binary grid, find the shortest bridge to connect two islands.",
        "examples": [
            {
                "input": {
                    "grid": [
                        [
                            0,
                            1
                        ],
                        [
                            1,
                            0
                        ]
                    ]
                },
                "output": 1
            }
        ],
        "constraints": "grid.length == grid[i].length, 2 <= grid.length <= 100",
        "solution_code": "class Solution(object):\n    def shortestBridge(self, grid):\n \n        def dfs(row, col):\n            if row < 0  or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] != 1:\n                return\n     \n            queue.append((row, col))\n            grid[row][col] = 2\n            dfs(row + 1, col)\n            dfs(row, col + 1)\n            dfs(row - 1, col)\n            dfs(row, col - 1)\n\n        # find the first 1\n        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] \n        queue = deque()\n        found = False\n        for i in range(len(grid)):\n            if found:\n                break\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    dfs(i, j)\n                    found = True\n                    break\n     \n        count = 0 \n        while queue:\n            n = len(queue)\n            for _ in range(n):\n                    # you want to check the neighbours potential since you kow curr\n                x, y = queue.popleft()\n                for newX, newY in directions:\n                    nx = x + newX\n                    ny = y + newY\n                    if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):\n                        if grid[nx][ny] == 1:\n                            return count\n                        elif grid[nx][ny] == 0:\n                            grid[nx][ny]  = -1\n                            queue.append((nx, ny))\n            count += 1\n\n        return count\n\n\n\n\n\n                \n"
    },
    {
        "question_number": 1367,
        "question_description": "Given a binary tree and a linked list, check if the list exists as a downward path in the tree.",
        "examples": null,
        "constraints": "The tree has at most 3,000 nodes",
        "solution_code": "class Solution(object):\n    def isSubPath(self, head, root):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n        if self.dfs(head, root):\n            return True\n        \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    def dfs(self, listNode, treeNode):\n        if not listNode:\n            return True\n\n        if not treeNode or listNode.val != treeNode.val:\n            return False\n        \n        return self.dfs(listNode.next, treeNode.left) or self.dfs(listNode.next, treeNode.right)"
    },
    {
        "question_number": 1590,
        "question_description": "Given an integer array nums and an integer p, remove the minimum number of elements such that the remaining sum is divisible by p.",
        "examples": [
            {
                "input": {
                    "nums": [
                        3,
                        1,
                        4,
                        2
                    ],
                    "p": 6
                },
                "output": 1
            }
        ],
        "constraints": "1 <= nums.length <= 10^5",
        "solution_code": "class Solution(object):\n    def minSubarray(self, nums, p):\n\n        if len(nums) == 1:\n            if nums[0] % p == 0:\n                return 0\n            return -1\n        \n        seen = {}\n        seen[0] = -1\n        total = 0\n        min_len = len(nums)\n        target = sum(nums) % p\n        \n        if target == 0:\n\n            return 0\n        \n        curr = 0\n        for i in range(len(nums)):\n            curr += nums[i]\n            curr %= p\n\n            missing = curr - target \n            missing %= p\n\n            if missing in seen:\n                min_len = min(i - seen[missing], min_len)\n\n            seen[curr] = i\n        return -1 if min_len == len(nums) else min_len\n\n\n        \n"
    },
    {
        "question_number": 3043,
        "question_description": "Given an array of strings, find the longest common prefix among them.",
        "examples": [
            {
                "input": {
                    "strs": [
                        "flower",
                        "flow",
                        "flight"
                    ]
                },
                "output": "fl"
            }
        ],
        "constraints": "1 <= strs.length <= 200",
        "solution_code": "class Solution(object):\n    def longestCommonPrefix(self, arr1, arr2):\n        prefix_set = set()\n\n        # Generate all prefixes for numbers in `arr1`\n        for n in arr1:\n            while n and n not in prefix_set:\n                prefix_set.add(n)\n                n = n // 10\n\n        res = 0\n\n        # Find the longest prefix match for numbers in `arr2`\n        for n in arr2:\n            while n and n not in prefix_set:\n                n = n // 10\n            if n:\n                res = max(res, len(str(n)))  # Update the longest prefix length\n\n        return res"
    },
    {
        "question_number": 3,
        "question_description": "Given a string, find the length of the longest substring without repeating characters.",
        "examples": [
            {
                "input": {
                    "s": "abcabcbb"
                },
                "output": 3
            }
        ],
        "constraints": "0 <= s.length <= 5 * 10^4",
        "solution_code": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n  \n        best = 0\n        seen = set()\n        l = 0 \n        \n        for r in range(len(s)):\n            while (s[r] in seen):\n                seen.remove(s[l])\n                l += 1\n            seen.add(s[r])\n            best = max(best, r - l + 1)\n\n        return best"
    },
    {
        "question_number": 9,
        "question_description": "Determine whether an integer is a palindrome.",
        "examples": [
            {
                "input": {
                    "x": 121
                },
                "output": true
            }
        ],
        "constraints": "-2^31 <= x <= 2^31 - 1",
        "solution_code": "class Solution(object):\n    def isPalindrome(self, x):\n   \n        return str(x) == str(x)[::-1]"
    },
    {
        "question_number": 16,
        "question_description": "Given an array nums and an integer target, return the sum of the three integers that is closest to target.",
        "examples": [
            {
                "input": {
                    "nums": [
                        -1,
                        2,
                        1,
                        -4
                    ],
                    "target": 1
                },
                "output": 2
            }
        ],
        "constraints": "3 <= nums.length <= 10^3",
        "solution_code": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n \n        nums.sort()\n\n\n        if len(nums) < 3:\n            return -1\n        closest = float('inf')\n\n        for i in range(len(nums) - 2):\n            l = i + 1\n            r = len(nums) - 1\n    \n            while(l < r):\n                curr = nums[i] + nums[l] + nums[r]\n                if curr == target:\n                    return target\n                # need to check for closest\n                if (abs(curr - target) < abs(closest - target)):\n                    closest = curr\n                if curr > target:\n                    r-= 1\n                else:\n                \n                    l+= 1\n        return closest"
    },
    {
        "question_number": 22,
        "question_description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
        "examples": [
            {
                "input": {
                    "n": 3
                },
                "output": [
                    "((()))",
                    "(()())",
                    "(())()",
                    "()(())",
                    "()()()"
                ]
            }
        ],
        "constraints": "1 <= n <= 8",
        "solution_code": "class Solution(object):\n    def generateParenthesis(self, n):\n    \n        def backtrack(s , left, right):\n            if len(s) == 2 * n:\n                result.append(s)\n                return \n            if left < n:\n                backtrack(s +'(', left +1, right)\n            if right < left:\n                backtrack(s + ')', left, right + 1)\n        result = []\n        backtrack(\"\", 0, 0)\n        return result\n"
    },
    {
        "question_number": 27,
        "question_description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place.",
        "examples": null,
        "constraints": "The order of elements can be changed.",
        "solution_code": "class Solution(object):\n    def removeElement(self, nums, val):\n \n        l = 0\n        r = len(nums) - 1\n        count2 = 0\n        while (l <= r):\n            # move the val to pos r\n            if nums[l] == val:\n                nums[l], nums[r] = nums[r], nums[l]\n                r -= 1\n                count += 1\n            else:\n                l += 1\n                count2 += 1\n        return count2\n    "
    },
    {
        "question_number": 37,
        "question_description": "Solve a given Sudoku puzzle by filling in the empty cells.",
        "examples": null,
        "constraints": "The input board is partially filled with digits and empty cells represented by '.'.",
        "solution_code": "class Solution(object):\n    def solveSudoku(self, board):\n   \n        def isValid(num, row, col):\n            # check row\n            for j in range(9):\n                if board[row][j] == num:\n                    return False\n\n            # check col\n            for i in range(9):\n                if board[i][col] == num:\n                    return False\n            \n            # check 3x3\n            box_row = 3 * (row // 3)\n            box_col = 3 * (col // 3)\n            for i in range(box_row, box_row + 3):\n                for j in range(box_col, box_col + 3):\n                    if board[i][j] == num:\n                        return False\n            return True\n        \n        def backtrack():\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in map(str, range(1,10)):\n                            if isValid(num, i, j):\n                                board[i][j] = num\n                                if backtrack():\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n        backtrack()"
    },
    {
        "question_number": 43,
        "question_description": "Given two non-negative integers num1 and num2 represented as strings, return the product as a string.",
        "examples": null,
        "constraints": "The input numbers are strings without leading zeros.",
        "solution_code": "class Solution(object):\n    def multiply(self, num1, num2):\n    \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        # Initialize a result array of zeros with a max possible length of len(num1) + len(num2)\n        result = [0] * (len(num1) + len(num2))\n        \n        # Reverse both strings to facilitate positional multiplication from the least significant digit\n        num1, num2 = num1[::-1], num2[::-1]\n        \n        # Multiply each digit in num1 by each digit in num2\n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                # Multiply the current digits and add to the corresponding position in the result\n                digit1, digit2 = int(num1[i]), int(num2[j])\n                product = digit1 * digit2\n                result[i + j] += product  # Add product to the current position\n                \n                # Manage carry for the next position\n                result[i + j + 1] += result[i + j] // 10\n                result[i + j] %= 10\n        \n        # Remove leading zeros from the result if any\n        while len(result) > 1 and result[-1] == 0:\n            result.pop()\n        \n        # Join digits and reverse to form the final product string\n        return ''.join(map(str, result[::-1]))"
    },
    {
        "question_number": 54,
        "question_description": "Given an m x n matrix, return all elements of the matrix in spiral order.",
        "examples": null,
        "constraints": "The matrix is non-empty.",
        "solution_code": "class Solution(object):\n    def spiralOrder(self, matrix):\n\n        if not matrix or not matrix[0]:\n            return []\n\n        result = []\n        top, bottom = 0, len(matrix) - 1\n        left, right = 0, len(matrix[0]) - 1\n\n        while top <= bottom and left <= right:\n            # Traverse from left to right along the top row\n            for col in range(left, right + 1):\n                result.append(matrix[top][col])\n            top += 1  # Move the top boundary down\n\n            # Traverse from top to bottom along the right column\n            for row in range(top, bottom + 1):\n                result.append(matrix[row][right])\n            right -= 1  # Move the right boundary left\n\n            # Traverse from right to left along the bottom row\n            if top <= bottom:\n                for col in range(right, left - 1, -1):\n                    result.append(matrix[bottom][col])\n                bottom -= 1  # Move the bottom boundary up\n\n            # Traverse from bottom to top along the left column\n            if left <= right:\n                for row in range(bottom, top - 1, -1):\n                    result.append(matrix[row][left])\n                left += 1  # Move the left boundary right\n\n        return result\n"
    },
    {
        "question_number": 63,
        "question_description": "Given an m x n grid with obstacles, find the number of unique paths from top-left to bottom-right.",
        "examples": null,
        "constraints": "Obstacles are represented by 1s, free spaces by 0s.",
        "solution_code": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n\n        rows = len(obstacleGrid)\n        cols = len(obstacleGrid[0])\n\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1] == 1:\n            return 0\n    \n        dp = [[0 for _ in range(len(obstacleGrid[0]))] for _ in range(len(obstacleGrid))]\n\n        dp[0][0] = 1\n        for i in range(1, len(obstacleGrid)):\n            if obstacleGrid[i][0] != 1 and dp[i - 1][0]:\n                dp[i][0] = 1\n            \n        for i in range(1, len(obstacleGrid[0])):\n            if obstacleGrid[0][i] != 1 and dp[0][i - 1]:\n                dp[0][i] = 1\n        \n        for i in range(1, len(obstacleGrid)):\n            for j in range(1, len(obstacleGrid[0])):\n\n                if obstacleGrid[i][j] == 1:\n                    continue\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j - 1]\n\n        return dp[-1][-1]"
    },
    {
        "question_number": 74,
        "question_description": "Write an efficient algorithm that searches for a value in an m x n matrix with sorted rows and columns.",
        "examples": null,
        "constraints": "Assume matrix rows are sorted.",
        "solution_code": "needa fix"
    },
    {
        "question_number": 75,
        "question_description": "Given an array with n objects colored red, white, or blue, sort them in-place.",
        "examples": null,
        "constraints": "Do not use library sorting functions.",
        "solution_code": "class Solution(object):\n    def sortColors(self, nums):\n     \n        # Pointers for the boundaries of 0s and 2s\n        left, right = 0, len(nums) - 1\n        current = 0\n\n        # Iterate through the list\n        while current <= right:\n            if nums[current] == 0:\n                # Swap current element with the left boundary\n                nums[left], nums[current] = nums[current], nums[left]\n                left += 1\n                current += 1\n            elif nums[current] == 2:\n                # Swap current element with the right boundary\n                nums[right], nums[current] = nums[current], nums[right]\n                right -= 1\n            else:\n                # Move past 1s\n                current += 1\n"
    },
    {
        "question_number": 91,
        "question_description": "Given a string containing digits, return the number of ways to decode it.",
        "examples": null,
        "constraints": "The string contains only digits.",
        "solution_code": "class Solution(object):\n    def\n        # If the string is empty or starts with '0', it cannot be decoded\n        if not s or s[0] == '0':\n            return 0\n\n        # prev1: Number of ways to decode up to the previous character\n        # prev2: Number of ways to decode up to the character before the previous one\n        prev1 = 1  # Represents dp[i-1]\n        prev2 = 1  # Represents dp[i-2]\n\n        # Loop through the string starting from the second character\n        for i in range(1, len(s)):\n            curr = 0  # Current number of ways to decode up to index i\n            \n            # If the current character is a valid single-digit number (1-9), it can be decoded\n            if s[i] != '0':\n                curr += prev1\n            \n            # Check if the last two characters form a valid two-digit number (10-26)\n            two = int(s[i - 1:i + 1])  # Extract the two-digit number\n            if 10 <= two <= 26:\n                curr += prev2\n            prev2, prev1 = prev1, curr\n        \n        # Return the final number of ways to decode the entire string\n        return prev1"
    },
    {
        "question_number": 116,
        "question_description": "Connect each node with its next right node in a perfect binary tree.",
        "examples": null,
        "constraints": "Assume it is a perfect binary tree.",
        "solution_code": "class Solution(object):\n    def connect(self, root):\n\n        if not root:\n            return None\n\n        leftmost = root\n\n        # go through each height\n        while leftmost.left:\n            head = leftmost\n            # go thru the horizontal\n            while head:\n                head.left.next = head.right\n                # link children nodes\n                if head.next:\n                    head.right.next = head.next.left\n                head = head.next\n            leftmost = leftmost.left\n        return root"
    },
    {
        "question_number": 124,
        "question_description": "Given a non-empty binary tree, find the maximum path sum.",
        "examples": null,
        "constraints": "The number of nodes is in the range [-10^4, 10^4].",
        "solution_code": "class Solution(object):\n    def maxPathSum(self, root):\n    \n        self.max_sum = float('-inf') \n        \n        # post order dfs\n        def gain(node):\n            if not node:\n                return 0\n            \n            left = max(gain(node.left), 0)\n            right = max(gain(node.right), 0)\n\n            curr = node.val + left + right\n            self.max_sum = max(curr, self.max_sum)\n\n            return node.val + max(left, right)\n        gain(root)\n        return self.max_sum"
    },
    {
        "question_number": 133,
        "question_description": "Given a reference of a node in a connected undirected graph, return a deep copy of the graph.",
        "examples": null,
        "constraints": "The number of nodes is in the range [0, 100].",
        "solution_code": "class Solution(object):\n    def cloneGraph(self, node):\n        \"\"\"\n        :type node: Node\n        :rtype: Node\n        \"\"\"\n        if not node:\n            return None\n        clones = {} # og -> clone\n\n        queue = deque([node])\n        clones[node] = Node(node.val, [])   #for starting node\n\n        while queue:\n            curr = queue.popleft()\n\n            for n in curr.neighbors:\n                if n not in clones:\n                    clones[n] = Node(n.val, [])\n                    queue.append(n)\n                clones[curr].neighbors.append(clones[n])\n                \n        return clones[node]\n"
    },
    {
        "question_number": 140,
        "question_description": "Given a string s and a dictionary of words, add spaces in s to construct all sentences.",
        "examples": null,
        "constraints": "1 <= s.length <= 20",
        "solution_code": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n    \n        words = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n                \n            if start == len(s):\n                return [\"\"]\n            \n            sentences = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in words:\n                    remaining = backtrack(end)\n                    # backtrack part\n                    for sen in remaining:\n                        if sen:\n                            sentences.append(word + \" \" + sen)\n                        else:\n                            sentences.append(word)\n            memo[start] = sentences\n            return sentences\n        return backtrack(0)"
    },
    {
        "question_number": 163,
        "question_description": "Given a sorted integer array and a range, find the missing ranges in the array.",
        "examples": null,
        "constraints": "0 <= nums.length <= 1000",
        "solution_code": "class Solution(object):\n    def findMissingRanges(self, nums, lower, upper):\n\n        res = []\n\n        # Step 1: Check for missing range before the first number\n        if nums and lower < nums[0]:\n            res.append([lower, nums[0] - 1])\n\n        # Step 2: Check for missing ranges between consecutive numbers\n        for i in range(1, len(nums)):\n            if nums[i - 1] + 1 < nums[i]:\n                res.append([nums[i - 1] + 1, nums[i] - 1])\n\n        # Step 3: Check for missing range after the last number\n        if nums and nums[-1] < upper:\n            res.append([nums[-1] + 1, upper])\n\n        # Handle edge case where nums is empty\n        if not nums:\n            res.append([lower, upper])\n\n        return res"
    },
    {
        "question_number": 246,
        "question_description": "Determine if a number is strobogrammatic (looks the same upside down).",
        "examples": null,
        "constraints": "The number has only digits 0, 1, 6, 8, or 9.",
        "solution_code": "class Solution(object):\n    def isStrobogrammatic(self, num):\n\n        mine = {\n            '1' : '1',\n            '6' : '9',\n            '9' : '6',\n            '8' : '8',\n            '0' : '0'\n        }\n\n        l = 0\n        r = len(num) - 1\n\n        while (l <= r):\n            if (num[l] not in mine or mine[num[l]] != num[r]):\n                return False\n            l += 1\n            r -= 1\n        return True"
    },
    {
        "question_number": 269,
        "question_description": "Given a list of words in alien dictionary order, return the order of characters.",
        "examples": null,
        "constraints": "1 <= words.length <= 100",
        "solution_code": "didnt do yet"
    },
    {
        "question_number": 273,
        "question_description": "Convert a non-negative integer to English words representation.",
        "examples": null,
        "constraints": "0 <= num <= 2^31 - 1",
        "solution_code": "class Solution(object):\n    def numberToWords(self, num):\n\n        if num == 0:\n            return \"Zero\"\n        \n        # Helper function to convert numbers less than 1000 to words\n        def helper(n):\n            if n == 0:\n                return \"\"\n            elif n < 20:\n                return below_20[n] + \" \"\n            elif n < 100:\n                return tens[n // 10] + \" \" + helper(n % 10)\n            else:\n                return below_20[n // 100] + \" Hundred \" + helper(n % 100)\n        \n        # Arrays for words mapping\n        below_20 = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        # Main logic\n        res = \"\"\n        for i, unit in enumerate(thousands):\n            if num % 1000 != 0:\n                res = helper(num % 1000) + unit + \" \" + res\n            num //= 1000\n        \n        return res.strip()"
    },
    {
        "question_number": 328,
        "question_description": "Group all odd-indexed nodes together followed by even-indexed nodes.",
        "examples": null,
        "constraints": "The number of nodes in the linked list is in the range [0, 10^4].",
        "solution_code": "\nclass Solution(object):\n    def oddEvenList(self, head):\n          \n        if not head:\n            return head\n        \n        # Initializing separate lists for odd and even nodes\n        odd_head = ListNode(0)\n        even_head = ListNode(0)\n        odd = odd_head\n        even = even_head\n        is_odd = True  # To track whether the node is odd or even\n        \n        # Traverse through the linked list\n        temp = head\n        while temp:\n            if is_odd:\n                odd.next = temp\n                odd = odd.next\n            else:\n                even.next = temp\n                even = even.next\n            # Toggle between odd and even\n            is_odd = not is_odd\n            temp = temp.next\n        \n        # Connect the end of odd list to the beginning of even list\n        odd.next = even_head.next\n        # Ensure the end of even list points to None\n        even.next = None\n        \n        return odd_head.next"
    },
    {
        "question_number": 333,
        "question_description": "Given a binary tree, find the size of the largest subtree that is a valid BST.",
        "examples": null,
        "constraints": "The number of nodes in the tree is in the range [0, 10^4].",
        "solution_code": "class Solution(object):\n    def largestBSTSubtree(self, root):\n\n        # post order\n\n        def dfs(node):\n            if not node:\n                return True, float('inf'), float('-inf'), 0\n            leftBST, leftSmall, leftLarge, leftCount = dfs(node.left)\n            rightBST, rightSmall, rightLarge, rightCount = dfs(node.right)\n\n            if leftBST and rightBST and leftLarge < node.val < rightSmall:\n                return True, min(leftSmall, node.val), max(rightLarge, node.val), leftCount + rightCount + 1\n            else:\n                return False, 0, 0, max(leftCount, rightCount)\n\n        if not root:\n            return 0\n        _, _ , _, res = dfs(root)\n        return res  \n"
    },
    {
        "question_number": 378,
        "question_description": "Find the kth smallest element in a sorted matrix.",
        "examples": null,
        "constraints": "1 <= n <= 300",
        "solution_code": "class Solution(object):\n    def kthSmallest(self, matrix, k):\n         \n        # first find the right row then col\n\n        left = matrix[0][0]\n        right = matrix[-1][-1]\n        n = len(matrix)\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = n - 1\n\n            for i in range(n):\n                while j >= 0 and matrix[i][j] > mid:\n                    j -= 1\n                count +=  (j + 1)\n            \n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"
    },
    {
        "question_number": 386,
        "question_description": "Given an integer n, return numbers from 1 to n in lexicographical order.",
        "examples": null,
        "constraints": "1 <= n <= 5 * 10^4",
        "solution_code": "class Solution(object):\n    def lexicalOrder(self, n):\n        res =[]\n\n        curr = 1\n\n        for _ in range(n):\n            res.append(curr)\n            # Try to go deeper into the tree (append a '0' to the current number)\n            if curr * 10 <= n:\n                curr *= 10\n            else:\n                # If we can't go deeper, backtrack and try the next number\n                while curr % 10 == 9 or curr + 1 > n:\n                    curr //= 10\n                curr += 1\n        return res\n"
    },
    {
        "question_number": 415,
        "question_description": "Given two non-negative integers num1 and num2 represented as strings, return the sum of num1 and num2 as a string.",
        "examples": null,
        "constraints": "The input strings contain only digits and do not have leading zeros.",
        "solution_code": "class Solution(object):\n    def addStrings(self, num1, num2):\n    \n        return str(int(num1) + int(num2))"
    },
    {
        "question_number": 416,
        "question_description": "Given a non-empty array nums, determine if it can be partitioned into two subsets with equal sum.",
        "examples": null,
        "constraints": "Each element in the array is a positive integer.",
        "solution_code": "class Solution(object):\n    def canPartition(self, nums):\n \n        total_sum = sum(nums) \n\n        if total_sum % 2 != 0:\n            return False  \n        target = total_sum // 2  # Target for each subset\n        \n        # dp[i] will tell if we can form sum i\n        dp = [False] * (target + 1)  #\n        dp[0] = True  \n        \n        # Step 5: Iterate through each number in the array\n        for num in nums:\n            # Update DP array backwards to prevent using the same number multiple times\n            for i in range(target, num - 1, -1):\n                dp[i] = dp[i] or dp[i - num]  # Can we make sum i either before or by using num\n        \n        return dp[target]"
    },
    {
        "question_number": 443,
        "question_description": "Given an array of characters, compress it in-place.",
        "examples": null,
        "constraints": "Do not allocate extra space for another array.",
        "solution_code": "class Solution(object):\n    def compress(self, chars):\n\n        l = 0   # Position to write the compressed characters\n        count = 1 # Count of the current character\n        for r in range(1, len(chars) + 1):\n            if r < len(chars) and chars[r -1] == chars[r]:  \n                count += 1\n            else:\n                chars[l] = chars[r - 1]\n                l += 1\n                if count > 1:\n                    for c in str(count):\n                        chars[l] = c\n                        l += 1\n                count = 1\n        return l"
    },
    {
        "question_number": 493,
        "question_description": "Given an array of integers, return the number of reverse pairs.",
        "examples": null,
        "constraints": "A reverse pair is defined if i < j and nums[i] > 2 * nums[j].",
        "solution_code": "hard tbd"
    },
    {
        "question_number": 739,
        "question_description": "Given a list of temperatures, return a list that tells you how many days you would have to wait until a warmer temperature.",
        "examples": null,
        "constraints": "Each temperature is an integer.",
        "solution_code": "class Solution(object):\n    def dailyTemperatures(self, temperatures):\n\n        n = len(temperatures)\n        res = [0] * n\n        highest = -float('inf')\n        for i in range(n - 1, -1, -1):\n            curr = temperatures[i]\n\n            if curr >= highest:\n                highest = curr\n                continue\n            days =  1\n            while temperatures[i + days] <= curr:\n                days += res[i + days]   # this is hte important line \n            res[i] = days\n\n        return res"
    },
    {
        "question_number": 766,
        "question_description": "Given a matrix, return true if and only if every diagonal from top-left to bottom-right has the same elements.",
        "examples": null,
        "constraints": "The matrix can have any size.",
        "solution_code": "class Solution(object):\n    def isToeplitzMatrix(self, matrix):\n      \n        for i in range(1, len(matrix)):\n            for j in range(1, len(matrix[0])):\n               if matrix[i][j] != matrix[i - 1][j- 1]:\n                    return False\n        return True"
    },
    {
        "question_number": 700,
        "question_description": "Given the root of a binary search tree and a value, return the subtree rooted with that value.",
        "examples": null,
        "constraints": "All TreeNode values are unique.",
        "solution_code": "class Solution(object):\n    def searchBST(self, root, val):\n \n        if not root:\n            return None\n        queue = deque([root])\n\n        while (queue):\n            curr = queue.pop()\n            if not curr:\n                return None\n            if curr.val == val:\n                return curr\n            if curr.val < val:\n                queue.append(curr.right)\n            elif curr.val > val:\n                queue.append(curr.left)\n        return None\n"
    },
    {
        "question_number": 863,
        "question_description": "Given the root of a binary tree, a target node, and an integer k, return all nodes that are distance k from the target node.",
        "examples": null,
        "constraints": "The binary tree has up to 500 nodes.",
        "solution_code": "class Solution(object):\n    def distanceK(self, root, target, k):\n \n        def buildGraph(node, parent, mapping):\n            if not node:\n                return \n            if parent:\n                mapping[node].append(parent)\n                mapping[parent].append(node)\n            buildGraph(node.left, node, mapping)\n            buildGraph(node.right, node, mapping)\n            \n        mine = defaultdict(list)\n        buildGraph(root, None, mine)\n        queue = deque([target])\n\n        curr = 0\n        visited = set()\n        visited.add(target)\n        while queue and curr < k:\n            n = len(queue)\n            for _ in range(n):\n                temp = queue.popleft()\n                for neighbour in mine[temp]:\n                    if neighbour not in visited:\n                        queue.append(neighbour)\n                        visited.add(neighbour)\n            curr += 1\n\n        return [node.val for node in queue]"
    },
    {
        "question_number": 953,
        "question_description": "Given an alien dictionary, verify if a list of words is sorted according to it.",
        "examples": null,
        "constraints": "The alien dictionary consists of lowercase letters.",
        "solution_code": "class Solution(object):\n    def isAlienSorted(self, words, order):\n  \n        order1 = {}\n\n        for index, val in enumerate(order):\n            order1[val] = index\n\n        # go thru all the words in the list\n        for i in range(len(words) - 1):\n\n            # go thru the length of the current word\n\n            for j in range(len(words[i])):\n\n                # edge case (end)\n                if j >= len(words[i + 1]):\n                    return False\n\n                if words[i][j] != words[i + 1][j]:\n                    if order1[words[i][j]] > order1[words[i + 1][j]]:\n                        return False\n                    break\n        return True"
    },
    {
        "question_number": 1011,
        "question_description": "Given weights of packages and days D, find the least weight capacity of a ship to ship all packages within D days.",
        "examples": null,
        "constraints": "Each package has a positive weight.",
        "solution_code": "class Solution(object):\n    def shipWithinDays(self, weights, days):\n   \n        def check(limit):\n            curr = 0    \n\n            days1 = 1\n            for w in weights:\n                if w + curr > limit:\n                    days1 += 1\n                    curr = 0\n\n                curr += w\n            return days1 <= days\n\n\n        l = max(weights)\n        r = sum(weights)\n        while l < r:\n            mid = (l + r) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n        return l"
    },
    {
        "question_number": 1216,
        "question_description": "Given a string s and an integer k, determine if s is a k-palindrome.",
        "examples": null,
        "constraints": "The input string consists only of lowercase English letters.",
        "solution_code": "class Solution(object):\n    def isValidPalindrome(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        def is_palindrome_range(l, r, k):\n            \"\"\"Check if s[l:r+1] can be a palindrome with at most k removals.\"\"\"\n            while l < r:\n                if s[l] != s[r]:\n                    # If characters don't match, try removing one character (reduce k)\n                    if k == 0:\n                        return False\n                    return is_palindrome_range(l + 1, r, k - 1) or is_palindrome_range(l, r - 1, k - 1)\n                l += 1\n                r -= 1\n            return True\n\n        # Start with the entire string and up to k removals\n        return is_palindrome_range(0, len(s) - 1, k)"
    },
    {
        "question_number": 1209,
        "question_description": "Given a string and an integer k, remove adjacent duplicates in the string where k duplicates are adjacent.",
        "examples": null,
        "constraints": "The input string consists of lowercase letters.",
        "solution_code": "class Solution(object):\n    def removeDuplicates(self, s, k):\n \n        stack = []  # Each element is [character, count]\n        for char in s:\n            # Check if the stack  matches the current character\n            if stack and stack[-1][0] == char:\n                # Increment the count of the character\n                stack[-1][1] += 1\n                # If the count reaches k, remove the character from the stack\n                if stack[-1][1] == k:\n                    stack.pop()\n            else:\n                # Add the new character to the stack with a count of 1\n                stack.append([char, 1])\n\n        return \"\".join(char * count for char, count in stack)\n"
    },
    {
        "question_number": 1424,
        "question_description": "Given a list of lists, return the elements in a diagonal order.",
        "examples": null,
        "constraints": "The list elements may vary in size.",
        "solution_code": "class Solution(object):\n    def findDiagonalOrder(self, nums):\n  \n        if not nums:\n            return []\n        res= []\n        queue = deque([(0,0)])  \n\n        while queue:\n            row, col = queue.popleft()\n            res.append(nums[row][col])\n            if col == 0 and row < len(nums) - 1:\n                queue.append((row+1, col))\n            if col < len(nums[row]) - 1:\n                queue.append((row, col + 1))\n        return res"
    },
    {
        "question_number": 2419,
        "question_description": "Given an array of integers, return the length of the longest subarray with the maximum bitwise AND.",
        "examples": null,
        "constraints": "The array contains only non-negative integers.",
        "solution_code": "class Solution(object):\n    def longestSubarray(self, nums):\n \n        val = max(nums)  # Find the maximum value in the array\n\n        curr = 0  # Current subarray length for maximum value\n        longest = 0  # Longest subarray length for maximum value\n\n        for n in nums:\n            if n == val:\n                curr += 1  # Extend the subarray if the value matches\n            else:\n                longest = max(longest, curr)  # Update the longest length\n                curr = 0  # Reset current subarray length\n        \n        longest = max(longest, curr)\n        return longest\n"
    },
    {
        "question_number": 2807,
        "question_description": "Insert the GCD of two consecutive values in the nodes of a linked list.",
        "examples": null,
        "constraints": "Each node has a non-negative integer value.",
        "solution_code": "class Solution(object):\n    def insertGreatestCommonDivisors(self, head):\n        # Euclidean Algorithm\n        def calc_gcd(x, y):\n            while y != 0:\n                x,y = y, x % y\n            return x\n    \n        node1 = head\n        node2 = head.next\n\n        while node2:\n            val = calc_gcd(node1.val, node2.val)\n            node = ListNode(val)\n\n            node1.next = node\n            node.next = node2\n\n            node1 = node2\n            node2 = node2.next\n        return head"
    }
]